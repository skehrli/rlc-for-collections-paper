\section{Background on type qualifiers}
\label{sec:background}

\Cref{sec:must-call,sec:called-methods} describe
\emph{pluggable type systems}~\cite{FosterFFA99}---specialized type
systems that are layered on top of the type system of the host
language.  Types in a pluggable type system are composed of two parts:
a \emph{type qualifier} and a base type. The type qualifier is the
part of the type that is unique to the pluggable type system; the base
type is a type from the host language. Our implementation is in Java
(see \cref{sec:implementation}), so we use the Java syntax for type
qualifiers: ``\<@>'' before a type indicates that it is a type
qualifier, and a type without ``\<@>'' is a base type.

% the technical sections about the core accumulation systems: called methods,
% must-call, and the must call invoked worklist algorithm.

\section{Cooperating analyses for leak detection}
\label{sec:base-type-systems}

This section shows how we built a sound, modular, accumulation-based
resource leak checker.
Further details on novel features that improve the precision
of that checker are provided in
\cref{sec:lightweight-ownership,sec:reset-must-call,sec:must-call-choice}.

\Tool is composed of three cooperating analyses:
\begin{enumerate}
\item a taint tracking type system (\cref{sec:must-call}) computes a conservative
  \emph{overapproximation} of the set of methods that might need to be called
  on each expression in the program.
\item an accumulation type system (\cref{sec:called-methods}) computes
  a conservative \emph{underapproximation} of the set of methods that are
  actually called on each expression in the program.
\item a dataflow analysis (\cref{sec:must-call-invoked}) computes a set
  of owning pointers that contains at least one element for every resource.
  For each owning pointer, it checks the consistency of the results
  of the two type systems at each program
  point at which the pointer might go out of scope:
  if any method that might need to be called is not in the set of methods
  that definitely were called, it issues an error.
\end{enumerate}

\begin{figure}
  \lstinputlisting{simplesocket.txt}
  \caption{A simple example of a safe use of a \<Socket> resource.}
  \label{fig:example}
\end{figure}

\noindent
Throughout this section, we will refer to the motivating example
in \cref{fig:example}. This simple code shows
a safe use of a \<Socket>---a resource that must be closed before
it is deallocated.

\subsection{Inferring must-call obligations with a type system}
\label{sec:must-call}

\begin{figure}

\begin{tikzpicture}[->, shorten >= 1pt, auto, node distance=0.3cm]
  \tikzstyle{every state}=[fill=none,draw=none,text=black, minimum size = 0.5cm, shape = rectangle]
  
  \node[state]        (TOP)                                   {\parbox{4cm}  {\centering \small \<@MustCallUnknown> $= \top$}};
  \node[state]         (MCAB)      [below   = of TOP]        {\parbox{4cm}  {\centering \small \<@MustCall(\{"a", "b"\})>}};
  \node[state]         (MCA)    [below  = of MCAB, xshift=-2.2cm]         {\parbox{4cm} {\centering \small \<@MustCall(\{"a"\})>}};
  \node[state]         (MCB)    [below  = of MCAB, xshift=2.2cm]         {\parbox{4cm} {\centering \small \<@MustCall(\{"b"\})>}};
  \node[state]         (BOT)     [below      = of MCAB, yshift=-0.8cm]       {\parbox{4cm}  {\centering \small \<@MustCall(\{\})> $= \bot$}};

  \path

  (MCAB)        edge        node {} (TOP)
  
  (MCA)         edge        node {} (MCAB)
  (MCB)         edge        node {} (MCAB)
  
  (BOT)         edge        node {} (MCA)
  (BOT)         edge        node {} (MCB)

  ;

\end{tikzpicture}
%\precaptionspace
%\vspace{0.25cm}
\caption{Part of the type hierarchy for representing which methods must be
  called.
  If an expression's type has qualifier \<@Must\-Call(\{"a", "b"\})>, then
  the methods ``\<a>'' and ``\<b>'' might need to be called before the
  expression is deallocated.
  Arrows represent
  subtyping relationships.
  The diagram shows a part of the type hierarchy; the full hierarchy is a
  lattice of arbitrary size. 
}
\label{fig:must-call-hierarchy}
\end{figure}

The first important fact that our checker must establish
is which methods might actually need to be called on
a given program element. The checker described in this section
tracks the methods that an object should call before it
is deallocated in a general way---it is not necessarily specific
to resource leaks. It produces a conservative overapproximation of the
set of methods that might actually need to be called on an object.

For example, consider \cref{fig:example}. When \<s> is initially
created, it is assigned the value \<null>, which has no obligations
to call particular methods. However, as soon as the \<Socket> constructor
is invoked and \<s> is assigned, \<s> has an obligation to call the
\<close()> method.

The type system supports two qualifiers: \<@MustCall> and
\<@MustCallUnknown>. The \<@MustCall> qualifier's arguments are the
methods that the annotated type should call. The type
\<@MustCall(\{"a"\}) Object obj> means that before \<obj> is
deallocated, \<obj.a()> should be called. Our implementation
uses local type inference (implemented via a dataflow algorithm)
to propagate these facts. For example, in \cref{fig:example}, the
type of \<s> (and the \<new> expression on the right-hand side of
the assignment) is \<@MustCall("close")> as soon as it is assigned.

Note that the type \<@MustCall("close")>
can represent anything that \emph{might} need to
call \<close()>: for example, at the entrance to
the \<finally> block in \cref{fig:example}, \<s>'s
actual value might either be \<null>, which does not
need to call any methods, or an open \<Socket>, which does.
Thus, either the obligation to close or no obligation at all
can be represented by the static
type \<@MustCall(\{"close"\}) Socket>, which can be read as "a
Socket that might need to call close before it is deallocated".

Part of the type hierarchy appears in \cref{fig:must-call-hierarchy}.
All types are subtypes of \<@MustCallUnknown>.
The subtyping relationship is for two \<@MustCall> types with sets
of required methods $A$ and $B$ is:
\trule{A \subseteq B}{\<@MustCall(A)> \sqsubseteq \<@MustCall(B)>}

The default type qualifier for raw base types is \<@MustCall(\{\})>.
By writing another type qualifier on the declaration of a class, a
user can specify a different default for raw types of that class.
Using this mechanism, the qualified type of the \<new> expression
in \cref{fig:example}
is \<@MustCall(\{"close"\}) Socket>. Our implementation
also provides an ``inheritable'' version of the \<@MustCall> annotation,
which allows us to annotate a class (or interface) and all of its subtypes.
For example, we use such an annotation on \<java.io.Closeable> to indicate
that all \<Closeable> objects must have the \<close()> method called before
they are deallocated.

A benefit of using a type system for tracking must-call obligations is
that \Tool can use local type inference to refine the obligations of
a particular variable. For example, if the only assignment to \<s>
in \cref{fig:example} were the initial assignment to \<null>, then
\Tool would be able to determine that \<s> does not have a must-call
obligation.

\subsection{Inferring called methods with an accumulation analysis}
\label{sec:called-methods}

Our type system for inferring which methods are definitely called on an object
is an extension of a similar system
from prior work~\cite{KelloggRSSE2020}.  The primary difference in our
version is that methods are considered called even if they throw an exception
(in the prior work, a method was only considered ``called'' when it terminated
successfully)---a necessity in Java because the \<close()> method
in \<java.io.Closeable> is specified to possibly throw an \<IOException>.
The remainder of this section is a brief explanation
of the type system from prior work~\cite{KelloggRSSE2020}, which contains
a more full description.

This checker is an \emph{accumulation analysis}: a special case
of typestate analysis~\cite{StromY86} in which:
\begin{enumerate}
\item the order in which operations are performed cannot affect what is
  subsequently permitted, and
\item executing more operations does not add restrictions---that is,
  the set of permitted operations after executing some operation is always
  a superset of the set of permitted operations before executing that operation.
\end{enumerate}
This special case of typestate analysis is useful because it does not
require a whole-program alias analysis for soundness, and instead
can be implemented as a standard pluggable type system.

The checker supports two qualifiers: \<@CalledMethods>
and \<@CalledMethodsBottom>. The type \<@CalledMethods(>$A$\<) Object>
represents an object on which the methods in the set $A$ have definitely
been called (other methods not in $A$ might also have been called).
\<@CalledMethodsBottom> is a subtype of every other Called Methods type; the subtyping
rule between any two \<@CalledMethods> annotations with method sets $A$
and $B$ is:
\trule{B \subseteq A}{\<@CalledMethods(A)> \sqsubseteq \<@CalledMethods(B)>}
The resulting lattice has \<@CalledMethods(\{\})> as its top type.

Called Methods types are inferred within method bodies---so for example
in \cref{fig:example}, the type of \<s> is initially \<@CalledMethods({})>,
but transitions to \<@CalledMethods("close")> on all paths after the
\<finally> block.

\subsection{Consistency checking}
\label{sec:must-call-invoked}

\begin{algorithm}[t]
  \caption{Finding missed calls.  Structured like pseudocode in~\cite{TorlakC10}.}
  \label{alg:consistency-checker}
  \begin{algorithmic}[1]
  \Procedure{FindMissedCalls}{$CFG$}
  \State // \textit{elements of D(s) are of the form} $\langle P, s' \rangle$,
  \State // \textit{where $P$ is a set of locals and $s'$ is a statement}
  \State // \textit{with a must-call obligation}
  \State $D \gets \{ s \mapsto \emptyset\ |\ s \in \mathit{Statement} \}$
  \State // \textit{initialize from all calls with a must-call obligation}
  \For{$s \in \mathit{Statement}$} \label{li:start-init}
    \For{$v \in \textsc{MCObligations}(s)$}
%    \If{$s$ is \lstinline{p = foo()} and \textsc{HasNonEmptyMustCall}(foo)}
      \State $\forall t \in \mathit{succ}(s)\ .\ D(t) \leftarrow D(t) \cup \langle \{v\}, s \rangle$
    \EndFor \label{li:end-init}
  \EndFor
  \While{$D$ is not at fixed point}
    \State $s \gets \textsc{ChooseFrom}(\mathit{Statement})$
    \State $\langle P, s' \rangle \gets \textsc{ChooseFrom}(D(s))$
    \State // \textit{Is the must-call obligation for some var in } $P$
    \State // \textit{satisfied either before }$s$\textit{ or by } $s$\textit{?}
    \If{\textsc{MCSatisfied}(P,s)} \label{li:check-satisfied}
    \State // \textit{don't propagate to successors}
    \State \textbf{continue} 
    \EndIf
    \If{\textsc{EndOfScope}(P,s)} \label{li:end-scope}
      \State // \textit{must call not satisfied, so we have a leak}
      \State report a must-call violation for $s'$
    \Else
    \State $kill \gets \{\textsc{LHS}(s)\}$ \label{li:compute-kill}
    \State $gen \gets$ \textsc{CreatesAlias}(P,s) ? $\{\textsc{LHS}(s)\}$ : $\emptyset$ \label{li:compute-gen} 
    % \If{$s$ is \lstinline{p = q} and $q \in P$}
    % \State $gen \gets \{p\}$
    % \EndIf
    \State $N \gets (P - kill) \cup gen$ \label{li:compute-new-mc-aliases}
    \State // \textit{we even propagate }$\emptyset$\textit{; error reported at exit}
    \State $\forall t \in \mathit{succ}(s)\ .\ D(t) \leftarrow D(t) \cup \langle
    N, s' \rangle$ \label{li:prop-to-succs}
    \EndIf
  \EndWhile \label{li:alg-loop-end}
  \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Basic helper functions for \Cref{alg:consistency-checker}.}
  \label{alg:helpers}
  \begin{algorithmic}[1]
  \State // \textit{what must-call obligations does s introduce?}
  \Procedure{MCObligations}{$s$}
  \If{$s$ is \lstinline{p = foo(...)} and \textsc{HasMCReturn}(\lstinline{foo})}
    \State \Return $\{ p \}$
  \Else
    \State \Return $\emptyset$
  \EndIf
  \EndProcedure
  \State // \textit{Is the must-call obligation for some variable in P satisfied either before s or by s?}
  \Procedure{MCSatisfied}{$P,s$}
  \State \Return $\exists p \in P .\ \textsc{MCBefore}(p,s) \subseteq \textsc{CMBefore(p,s)}$
  \EndProcedure
  \State // \textit{Does s end the scope in which P's must-call obligation can
  be satisfied?}
  \Procedure{EndOfScope}{$P,s$}
  \State \Return \textsc{IsExit}$(s)$
  \EndProcedure
  \State // \textit{Does s introduce a must alias for a var in P?}
  \Procedure{CreatesAlias}{$P,s$}
    \State \Return $s$ is \lstinline{p = q} $\wedge\ q \in P$
  \EndProcedure
  \end{algorithmic}

\end{algorithm}

\todo{Use the example in \cref{fig:example} throughout this section
  to explain the algorithm, possibly extending it if needed.}

Given inferred \<@MustCall> obligations and \<@CalledMethods> types, the Must
Call Consistency Checker ensures that \<@MustCall> methods for each object
are always invoked before the object becomes unreachable.  Pseudocode for a
basic version of this checker appears in \Cref{alg:consistency-checker}, with
helper functions in \Cref{alg:helpers}.  In subsequent sections we will describe
various enhancements to this basic approach.

The checker performs an intra-procedural dataflow analysis over a control-flow
graph with nodes from a set $\mathit{Statement}$ of statements and a
$\mathit{succ}$ relation capturing control flow.  For simplicity, the pseudocode
assumes statements are normalized to a three-address form, with all intermediate
results stored in temporary variables.  \todo{give a list of all types of
statements: assignment, method call, return, field write?}

The analysis computes a set of facts $D(s)$ holding before each statement $s$. A
fact is of the form $\langle P, s' \rangle$, where $P$ is a set of variables and
$s'$ is a call statement with a non-empty \<@MustCall> obligation. The variables
in $P$ are \emph{must aliases} for $s'$:  hence, satisfying the \<@MustCall>
obligation for \emph{any} variable in $P$ is sufficient to satisfy the
obligation for $s'$.  (In \Cref{sec:must-call-choice} we shall generalize the
set of variables held in $P$.)  If the analysis discovers a fact $\langle P, s'
\rangle$ reaching the method exit, then the \<@MustCall> obligation for $s'$ may
not be satisfied, and an error is reported.

\Cref{alg:consistency-checker} proceeds as follows.
Lines~\ref{li:start-init}--\ref{li:end-init} initialize $D$ by scanning for
statements that introduce \<@MustCall> obligations.  In the basic checker, such
statements include any method call (or constructor call) returning an object
with a non-empty \<@MustCall> type (see \textsc{MCObligations} in
\Cref{alg:helpers}).  The fixed-point loop then proceeds by choosing some fact
$\langle P, s' \rangle$ from some $D(s)$ (our implementation uses a worklist for
efficiency).  If the \<@MustCall> obligation for $s'$ is satisfied before $s$
(\cref{li:check-satisfied}), the fact is not propagated further. For the basic
checker, \textsc{MCSatisfied} in \Cref{alg:helpers} checks whether there is some
variable $p \in P$ such that the inferred \<@MustCall> type for $p$ before $s$
($\textsc{MCBefore}(p,s)$) is contained in its \<@CalledMethods> type
($\textsc{CMBefore}(p,s)$), i.e., all \<@MustCall> methods have already been
invoked.
\todo{The names CMBefore and MCBefore are confusing - they're nearly identical.
  Can we think of better ones that are equally useful?}
If not satisfied, and if $s$ marks the end of the scope in which the
obligation can be met (\cref{li:end-scope}), a violation is reported, as some
\<@MustCall> method may not have been invoked.

If neither of these cases hold, the algorithm propagates the fact to
successors with an updated set $N$ of must aliases.  $N$ is computed in a
standard gen-kill style on
lines~\ref{li:compute-kill}--\ref{li:compute-new-mc-aliases}.  The kill set
simply consists of whatever variable (if any) appears on the left-hand side of
$s$.  The gen set is computed by checking if $s$ creates a new must alias for
some variable in $P$, using the \textsc{CreatesAlias} routine.  In
\Cref{alg:helpers} the routine simply checks for an assignment where the
right-hand side variable is in $P$; we present a more sophisticated version of
this routine in \Cref{sec:must-call-choice}.
Finally, \Cref{li:prop-to-succs} propagates the new fact to successors.  The
process continues until $D$ reaches a fixed point.  \todo{Tie this into a
running example?}

At this point, we have described a sound checker for \<@MustCall> obligations.
But for real code, this checker emits too many false positives.  Subsequent
sections will detail techniques to make the checker more precise.

% The Ownership Checker is a simple worklist algorithm that operates over the CFG.
% It maintains a set of owning pointers to objects, using a set of simple
% ownership rules:
% \begin{itemize}
% \item a newly-allocated object is owned
% \item the value returned by any method called is owned
% \end{itemize}

% These rules guarantee that there is at least one owning pointer to each
% object that might contain a resource. \Cref{sec:lightweight-ownership}
% gives more details on how ownership is transferred.

% When an owning pointer goes out of scope, the Ownership Checker
% compares the types computed by the Must Call Checker and the Called
% Methods Checker to determine if the requirements on the expression
% going out of scope have been fulfilled using the following process,
% supposing that some expression \<expr> is going out of scope at
% program point $P$:
% \begin{enumerate}
%   \item The Ownership Checker requests a Must Call type from the Must
%     Call Checker for \<expr> at $P$. Suppose this type is
%     \<@MustCall(>$A$\<)> for some set of methods $A$ (if the type is
%     \<@MustCallUnknown>, the Ownership Checker always issues an
%     error).
%   \item The Ownership Checker requests a Called Methods type from the
%     Called Methods Checker for \<expr> at $P$. Suppose this type is
%     \<@CalledMethods(>$B$\<)> for some set of methods $B$.
%   \item The Ownership Checker compares the sets $A$ and $B$. If
%     $A \supset B$, the Ownership Checker issues an error.
% \end{enumerate}

% The Ownership Checker also does a simple, intra-procedural must-alias
% analysis, to avoid issuing duplicate errors for e.g. constructor
% invocations that are assigned to local variables. At most one error
% for each must-alias set is ever issued. 

% LocalWords:  simplesocket MustCallUnknown MCAB MustCall MCA xshift MCB
% LocalWords:  yshift Closeable CalledMethods CalledMethodsBottom IsExit
% LocalWords:  FindMissedCalls MCSatisfied CreatesAlias MCObligations
% LocalWords:  HasMCReturn EndOfScope CMBefore MCBefore
