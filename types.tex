\section{Background on type qualifiers}
\label{sec:background}

\Cref{sec:must-call,sec:called-methods} describe
\emph{pluggable type systems}~\cite{FosterFFA99}---specialized type
systems that are layered on top of the type system of the host
language.  Types in a pluggable type system are composed of two parts:
a \emph{type qualifier} and a base type. The type qualifier is the
part of the type that is unique to the pluggable type system; the base
type is a type from the host language. Our implementation is in Java
(see \cref{sec:implementation}), so we use the Java syntax for type
qualifiers: ``\<@>'' before a type indicates that it is a type
qualifier, and a type without ``\<@>'' is a base type.

A type system checks programmer-written types.  Our system requires the
programmer to write types on method signatures, but within method bodies it
uses flow-sensitive type refinement, a dataflow analysis that performs type
inference.  This permits an expression to have different types on different
lines of the program.


% the technical sections about the core accumulation systems: called methods,
% must-call, and the must call invoked worklist algorithm.

\section{Cooperating analyses for leak detection}
\label{sec:base-type-systems}

This section presents a sound, modular, accumulation-based
resource leak checker.
\Cref{sec:lightweight-ownership,sec:reset-must-call,sec:must-call-choice}
enhance its precision.

\Tool is composed of three cooperating analyses:
\begin{enumerate}
\item a taint tracking type system (\cref{sec:must-call}) computes a conservative
  \emph{overapproximation} of the set of methods that might need to be called
  on each expression in the program.
\item an accumulation type system (\cref{sec:called-methods}) computes
  a conservative \emph{underapproximation} of the set of methods that are
  actually called on each expression in the program.
\item a dataflow analysis (\cref{sec:must-call-invoked}) computes a set
  of owning pointers that contains at least one element for every resource.
  For each owning pointer, it checks the consistency of the results
  of the two type systems at each program
  point at which the pointer might go out of scope:
  if any method that might need to be called is not in the set of methods
  that definitely were called, it issues an error.
\end{enumerate}

\begin{figure}
  \lstinputlisting{simplesocket.txt}
  \caption{A safe use of a \<Socket> resource.}
  \label{fig:example}
\end{figure}

\noindent
This section uses \cref{fig:example} as a motivating example.
It shows
a safe use of a \<Socket>---a resource that must be closed before
it is deallocated.

\subsection{Inferring must-call obligations with a type system}
\label{sec:must-call}

\begin{figure}

\begin{tikzpicture}[->, shorten >= 1pt, auto, node distance=0.3cm]
  \tikzstyle{every state}=[fill=none,draw=none,text=black, minimum size = 0.5cm, shape = rectangle]
  
  \node[state]        (TOP)                                   {\parbox{4cm}  {\centering \small \<@MustCallUnknown> $= \top$}};
  \node[state]         (MCAB)      [below   = of TOP]        {\parbox{4cm}  {\centering \small \<@MustCall(\{"a", "b"\})>}};
  \node[state]         (MCA)    [below  = of MCAB, xshift=-2.2cm]         {\parbox{4cm} {\centering \small \<@MustCall(\{"a"\})>}};
  \node[state]         (MCB)    [below  = of MCAB, xshift=2.2cm]         {\parbox{4cm} {\centering \small \<@MustCall(\{"b"\})>}};
  \node[state]         (BOT)     [below      = of MCAB, yshift=-0.8cm]       {\parbox{4cm}  {\centering \small \<@MustCall(\{\})> $= \bot$}};

  \path

  (MCAB)        edge        node {} (TOP)
  
  (MCA)         edge        node {} (MCAB)
  (MCB)         edge        node {} (MCAB)
  
  (BOT)         edge        node {} (MCA)
  (BOT)         edge        node {} (MCB)

  ;

\end{tikzpicture}
%\precaptionspace
%\vspace{0.25cm}
\caption{Part of the \<MustCall> type hierarchy for representing which methods must be
  called; the full hierarchy is a
  lattice of arbitrary size.
  If an expression's type has qualifier \<@Must\-Call(\{"a", "b"\})>, then
  the methods ``\<a>'' and ``\<b>'' might need to be called before the
  expression is deallocated.
  Arrows represent
  subtyping relationships.
}
\label{fig:must-call-hierarchy}
\end{figure}

The first important fact that our checker must establish
is which methods might need to be called on
a given object before the object is deallocated.
This type system is general---it is not specific
to resource leaks.

For example, consider \cref{fig:example}. When \<s> is initially
created, it is assigned the value \<null>, which has no obligations
to call particular methods. However, as soon as the \<Socket> constructor
is invoked and \<s> is assigned, \<s> has an obligation to call the
\<close()> method.

The type system supports two qualifiers: \<@MustCall> and
\<@MustCallUnknown>. The \<@MustCall> qualifier's arguments are the
methods that the annotated type must call. The type
\<@MustCall(\{"a"\}) Object obj> means that before \<obj> is
deallocated, \<obj.a()> should be called. Our implementation
uses flow-sensitive local type inference (implemented via a dataflow algorithm)
to propagate these facts. For example, in \cref{fig:example}, the
the \<new> expression has type \<@MustCall("close")>, and therefore
\<s> has that type after the assignment.

Note that the type \<@MustCall("close")>
can represent anything that \emph{might} need to
call \<close()>: for example, at the entrance to
the \<finally> block in \cref{fig:example}, \<s>'s
actual value might either be \<null>, which does not
need to call any methods, or an open \<Socket>, which does.
Thus, either the obligation to close or no obligation at all
can be represented by the static
type \<@MustCall(\{"close"\}) Socket>, which can be read as ``a
Socket that might need to call close before it is deallocated''.
The type-checker conservatively requires all these methods to be called,
and it issues a warning if they are not.

Part of the type hierarchy appears in \cref{fig:must-call-hierarchy}.
All types are subtypes of \<@MustCallUnknown>.
The subtyping relationship is for two \<@MustCall> types with sets
of required methods $A$ and $B$ is:
\trule{A \subseteq B}{\<@MustCall(A)> \sqsubseteq \<@MustCall(B)>}

The default type qualifier is \<@MustCall(\{\}) for base types without a
programmer-written type qualifier.\footnote{For unannotated local variables,
  flow-sensitive type refinement infers a type.}
% By writing another type qualifier on the declaration of a class, a
% user can specify a different default for raw types of that class.
Using this mechanism, the qualified type of the \<new> expression
in \cref{fig:example}
is \<@MustCall(\{"close"\}) Socket>. Our implementation
provides JDK annotations to require that every 
\<Closeable> object must have the \<close()> method called before
it is deallocated.

% also provides an ``inheritable'' version of the \<@MustCall> annotation,
% which allows us to annotate a class (or interface) and all of its subtypes.
% For example, we use such an annotation on \<java.io.Closeable> to indicate
% that all \<Closeable> objects must have the \<close()> method called before
% they are deallocated.

%% This is redundant, I think.
% A benefit of using a type system for tracking must-call obligations is
% that \Tool can use local type inference to refine the obligations of
% a particular variable. For example, if the only assignment to \<s>
% in \cref{fig:example} were the initial assignment to \<null>, then
% \Tool would be able to determine that \<s> does not have a must-call
% obligation.


\subsection{Inferring called methods with an accumulation analysis}
\label{sec:called-methods}

\todo{Mike changed ``our types system for inferring'' to ``our type system
  tracks''.  Let's lay off use of ``infer'' because it implies we have
  written a type inference tool, when what we have really written is a
  type-checking tool (with local type inference).}

Our type system tracks a conservative underapproximation of which methods have been called on an object.
It is an extension of a similar system
from prior work~\cite{KelloggRSSE2020}.  The primary difference in our
version is that a method is considered called even if it throws an
exception---a necessity in Java because the \<close()> method
in \<java.io.Closeable> is specified to possibly throw an \<IOException>.
In the prior work, a method was only considered ``called'' when it terminated
successfully.
The remainder of this section is a brief summary
of the prior work~\cite{KelloggRSSE2020}.

% This checker is an \emph{accumulation analysis}: a special case
% of typestate analysis~\cite{StromY86} in which:
% \begin{enumerate}
% \item the order in which operations are performed cannot affect what is
%   subsequently permitted, and
% \item executing more operations does not add restrictions---that is,
%   the set of permitted operations after executing some operation is always
%   a superset of the set of permitted operations before executing that operation.
% \end{enumerate}
% This special case of typestate analysis is useful because it does not
% require a whole-program alias analysis for soundness, and instead
% can be implemented as a standard pluggable type system.

The checker is an accumulation analysis whose accumulation qualifier is \<@CalledMethods>.
The type \<@CalledMethods(>$A$\<) Object>
represents an object on which the methods in the set $A$ have definitely
been called; other methods not in $A$ might also have been called.
The subtyping
rule is:
\trule{B \subseteq A}{\<@CalledMethods(A)> \sqsubseteq \<@CalledMethods(B)>}
The top type is \<@CalledMethods(\{\})>.
The qualifier \<@CalledMethodsBottom> is a subtype of every \<@CalledMethods> qualifier.

Thanks to flow-sensitive type refinement,
Called Methods types are inferred within method bodies.  For example,
in \cref{fig:example} the type of \<s> is initially \<@CalledMethods({})>,
but it transitions to \<@CalledMethods("close")> after the call to \<close>.


\subsection{Consistency checking}
\label{sec:must-call-invoked}

\begin{algorithm}[t]
  \caption{Finding missed calls.  Structured like pseudocode in~\cite{TorlakC10}.}
  \label{alg:consistency-checker}
  \begin{algorithmic}[1]
  \Procedure{FindMissedCalls}{$CFG$}
  \State // \textit{elements of D(s) are of the form} $\langle P, s' \rangle$,
  \State // \textit{where $P$ is a set of locals and $s'$ is a statement}
  \State // \textit{with a must-call obligation}
  \State $D \gets \{ s \mapsto \emptyset\ |\ s \in \mathit{Statement} \}$
  \State // \textit{initialize from all calls with a must-call obligation}
  \For{$s \in \mathit{Statement}$} \label{li:start-init}
    \For{$v \in \textsc{MCObligations}(s)$}
%    \If{$s$ is \lstinline{p = foo()} and \textsc{HasNonEmptyMustCall}(foo)}
      \State $\forall t \in \mathit{succ}(s)\ .\ D(t) \leftarrow D(t) \cup \langle \{v\}, s \rangle$
    \EndFor \label{li:end-init}
  \EndFor
  \While{$D$ is not at fixed point}
    \State $s \gets \textsc{ChooseFrom}(\mathit{Statement})$
    \State $\langle P, s' \rangle \gets \textsc{ChooseFrom}(D(s))$
    \State // \textit{Is the must-call obligation for some var in } $P$
    \State // \textit{satisfied either before }$s$\textit{ or by } $s$\textit{?}
    \If{\textsc{MCSatisfied}(P,s)} \label{li:check-satisfied}
    \State // \textit{don't propagate to successors}
    \State \textbf{continue} 
    \EndIf
    \If{\textsc{EndOfScope}(P,s)} \label{li:end-scope}
      \State // \textit{must call not satisfied, so we have a leak}
      \State report a must-call violation for $s'$
    \Else
    \State $kill \gets \{\textsc{LHS}(s)\}$ \label{li:compute-kill}
    \State $gen \gets$ \textsc{CreatesAlias}(P,s) ? $\{\textsc{LHS}(s)\}$ : $\emptyset$ \label{li:compute-gen} 
    % \If{$s$ is \lstinline{p = q} and $q \in P$}
    % \State $gen \gets \{p\}$
    % \EndIf
    \State $N \gets (P - kill) \cup gen$ \label{li:compute-new-mc-aliases}
    \State // \textit{we even propagate }$\emptyset$\textit{; error reported at exit}
    \State $\forall t \in \mathit{succ}(s)\ .\ D(t) \leftarrow D(t) \cup \langle
    N, s' \rangle$ \label{li:prop-to-succs}
    \EndIf
  \EndWhile \label{li:alg-loop-end}
  \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Basic helper functions for \Cref{alg:consistency-checker}.}
  \label{alg:helpers}
  \begin{algorithmic}[1]
  \State // \textit{what must-call obligations does s introduce?}
  \Procedure{MCObligations}{$s$}
  \If{$s$ is \lstinline{p = foo(...)} and \textsc{HasMCReturn}(\lstinline{foo})}
    \State \Return $\{ p \}$
  \Else
    \State \Return $\emptyset$
  \EndIf
  \EndProcedure
  \State // \textit{Is the must-call obligation for some variable in P satisfied either before s or by s?}
  \Procedure{MCSatisfied}{$P,s$}
  \State \Return $\exists p \in P .\ \textsc{MCBefore}(p,s) \subseteq \textsc{CMBefore(p,s)}$
  \EndProcedure
  \State // \textit{Does s end the scope in which P's must-call obligation can
  be satisfied?}
  \Procedure{EndOfScope}{$P,s$}
  \State \Return \textsc{IsExit}$(s)$
  \EndProcedure
  \State // \textit{Does s introduce a must alias for a var in P?}
  \Procedure{CreatesAlias}{$P,s$}
    \State \Return $s$ is \lstinline{p = q} $\wedge\ q \in P$
  \EndProcedure
  \end{algorithmic}

\end{algorithm}

\todo{Use the example in \cref{fig:example} throughout this section
  to explain the algorithm, possibly extending it if needed.}

Given inferred \<@MustCall> obligations and \<@CalledMethods> types, the Must
Call Consistency Checker ensures that \<@MustCall> methods for each object
are always invoked before the object becomes unreachable.  Pseudocode for a
basic version of this checker appears in \Cref{alg:consistency-checker}, with
helper functions in \Cref{alg:helpers}.  In subsequent sections we will describe
various enhancements to this basic approach.

The checker performs an intra-procedural dataflow analysis over a control-flow
graph with nodes from a set $\mathit{Statement}$ of statements and a
$\mathit{succ}$ relation capturing control flow.  For simplicity, the pseudocode
assumes statements are normalized to a three-address form, with all intermediate
results stored in temporary variables.  \todo{give a list of all types of
statements: assignment, method call, return, field write?}

The analysis computes a set of facts $D(s)$ holding before each statement $s$. A
fact is of the form $\langle P, s' \rangle$, where $P$ is a set of variables and
$s'$ is a call statement with a non-empty \<@MustCall> obligation. The variables
in $P$ are \emph{must aliases} for $s'$:  hence, satisfying the \<@MustCall>
obligation for \emph{any} variable in $P$ is sufficient to satisfy the
obligation for $s'$.  (In \Cref{sec:must-call-choice} we shall generalize the
set of variables held in $P$.)  If the analysis discovers a fact $\langle P, s'
\rangle$ reaching the method exit, then the \<@MustCall> obligation for $s'$ may
not be satisfied, and an error is reported.

\Cref{alg:consistency-checker} proceeds as follows.
Lines~\ref{li:start-init}--\ref{li:end-init} initialize $D$ by scanning for
statements that introduce \<@MustCall> obligations.  In the basic checker, such
statements include any method call (or constructor call) returning an object
with a non-empty \<@MustCall> type (see \textsc{MCObligations} in
\Cref{alg:helpers}).  The fixed-point loop then proceeds by choosing some fact
$\langle P, s' \rangle$ from some $D(s)$ (our implementation uses a worklist for
efficiency).  If the \<@MustCall> obligation for $s'$ is satisfied before $s$
(\cref{li:check-satisfied}), the fact is not propagated further. For the basic
checker, \textsc{MCSatisfied} in \Cref{alg:helpers} checks whether there is some
variable $p \in P$ such that the inferred \<@MustCall> type for $p$ before $s$
($\textsc{MCBefore}(p,s)$) is contained in its \<@CalledMethods> type
($\textsc{CMBefore}(p,s)$), i.e., all \<@MustCall> methods have already been
invoked.
\todo{The names CMBefore and MCBefore are confusing - they're nearly identical.
  Can we think of better ones that are equally useful?}
If not satisfied, and if $s$ marks the end of the scope in which the
obligation can be met (\cref{li:end-scope}), a violation is reported, as some
\<@MustCall> method may not have been invoked.

If neither of these cases hold, the algorithm propagates the fact to
successors with an updated set $N$ of must aliases.  $N$ is computed in a
standard gen-kill style on
lines~\ref{li:compute-kill}--\ref{li:compute-new-mc-aliases}.  The kill set
simply consists of whatever variable (if any) appears on the left-hand side of
$s$.  The gen set is computed by checking if $s$ creates a new must alias for
some variable in $P$, using the \textsc{CreatesAlias} routine.  In
\Cref{alg:helpers} the routine simply checks for an assignment where the
right-hand side variable is in $P$; we present a more sophisticated version of
this routine in \Cref{sec:must-call-choice}. \manu{Note that we could just return
empty set here and still be sound}
Finally, \Cref{li:prop-to-succs} propagates the new fact to successors.  The
process continues until $D$ reaches a fixed point.  \todo{Tie this into a
running example?}

At this point, we have described a sound checker for \<@MustCall> obligations.
But for real code, this checker emits too many false positives.  Subsequent
sections will detail techniques to make the checker more precise.

% The Ownership Checker is a simple worklist algorithm that operates over the CFG.
% It maintains a set of owning pointers to objects, using a set of simple
% ownership rules:
% \begin{itemize}
% \item a newly-allocated object is owned
% \item the value returned by any method called is owned
% \end{itemize}

% These rules guarantee that there is at least one owning pointer to each
% object that might contain a resource. \Cref{sec:lightweight-ownership}
% gives more details on how ownership is transferred.

% When an owning pointer goes out of scope, the Ownership Checker
% compares the types computed by the Must Call Checker and the Called
% Methods Checker to determine if the requirements on the expression
% going out of scope have been fulfilled using the following process,
% supposing that some expression \<expr> is going out of scope at
% program point $P$:
% \begin{enumerate}
%   \item The Ownership Checker requests a Must Call type from the Must
%     Call Checker for \<expr> at $P$. Suppose this type is
%     \<@MustCall(>$A$\<)> for some set of methods $A$ (if the type is
%     \<@MustCallUnknown>, the Ownership Checker always issues an
%     error).
%   \item The Ownership Checker requests a Called Methods type from the
%     Called Methods Checker for \<expr> at $P$. Suppose this type is
%     \<@CalledMethods(>$B$\<)> for some set of methods $B$.
%   \item The Ownership Checker compares the sets $A$ and $B$. If
%     $A \supset B$, the Ownership Checker issues an error.
% \end{enumerate}

% The Ownership Checker also does a simple, intra-procedural must-alias
% analysis, to avoid issuing duplicate errors for e.g. constructor
% invocations that are assigned to local variables. At most one error
% for each must-alias set is ever issued. 

% LocalWords:  simplesocket MustCallUnknown MCAB MustCall MCA xshift MCB
% LocalWords:  yshift Closeable CalledMethods CalledMethodsBottom IsExit
% LocalWords:  FindMissedCalls MCSatisfied CreatesAlias MCObligations
% LocalWords:  HasMCReturn EndOfScope CMBefore MCBefore
