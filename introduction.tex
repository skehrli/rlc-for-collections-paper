\section{Introduction}
\label{sec:intro}

%% Resource leaks are a classic problem, and extant approaches to preventing
%% them are either too expensive or unsound.

A resource leak occurs when some finite resource managed by the
programmer is not explicitly disposed of. In an unmanaged language
like C, that explicit resource might be memory; in a managed language
like Java, it might be a file descriptor, a socket, or a database
connection.  Resource leaks continue to cause severe bugs, even in
modern, heavily-used Java applications~\cite{ghanavati2020memory}.
This state-of-the-practice does not differ much from two decades
ago~\cite{WeimerN04}. \todo{If we know of any more studies that show resource
  leaks are a big problem, we should add citations to them here, too.}
Microsoft engineers consider resource leak bugs to be one of the most
significant development challenges~\cite{LoNZ2015}.  That
resource leaks remain such a serious problem despite decades of
research and improvements in languages and tooling shows that
preventing resource leaks remains an urgent, difficult, open problem.

%% An ideal tool for preventing resource leaks would be fast, sound, and precise.

Ideally, a tool for preventing resource leaks would be:
\begin{itemize}
\item \emph{applicable} to leakable resources in existing code with few or no code changes,
\item \emph{sound}, so that undetected resource leaks do not slip into
  the program;
\item \emph{precise}, so that developers are not bothered by excessive false positive
  warnings; and
\item \emph{fast}, so that it scales to real-world programs and
  developers can use it regularly.
\end{itemize}

%% Extant approaches fail at least one of these: bug finders like the analysis
%% in ecj are unsound; complex analyses based on typestate are either too slow
%% (cite the Eurosys 2019 paper on Grapple, with numbers on run time), unsound, or both.

Extant approaches fail at least one of these criteria.
Language-based features may not apply to all uses of resource variables:
Java's try-with-resources statement, for example, can
only close resource types that implement the \<java.lang.AutoCloseable> interface,
and cannot handle
common resource usage patterns that span multiple procedures. \manu{Also discuss
finalizers somewhere?}
Heuristic bug-finding tools for leaks, built into Java IDEs including
Eclipse~\cite{ecj-resource-leak} and IntelliJ
IDEA~\cite{idea-resource-leak}, 
are fast and applicable to legacy
code---but they are unsound and can be highly imprecise
(\cref{sec:compare}).
Inter-procedural typestate or dataflow analyses~\cite{TorlakC10,zuo2019grapple}
achieve more precise
results---and
can find more complex bugs than bug-finders, though they usually remain
unsound---but
they can require hours to analyze a large-scale modern Java program, due
to the costliness of precise whole-program analysis.
Finally, ownership type
systems~\cite{clarke2013ownership} as employed in languages like
Rust~\cite{klabnik2018rust} can prevent nearly all resource leaks (see
\cref{sec:rw-language}), but using them would require a significant rewrite for
a legacy Java codebase, a substantial task which is often infeasible.
% require
% significantly rewriting the program, 
% and prevents them from being applicable to legacy codebases and coding styles.

The essence of finding resource leaks in a Java-like language is
checking that a particular method (typically \<close()>) is called on
every object of a relevant class during its lifetime (i.e., before it
becomes unreachable).  We deem this a \emph{must-call} property.  Our
key insight is that checking must-call properties are an extended version of an
accumulation problem.
Our contribution is an \emph{accumulation analysis} for the resource leak
problem, which satisfies all four requirements:  it is applicable,
sound, precise, and fast.

An accumulation analysis~\cite{KelloggRSSE2020}
is a special-case of typestate analysis~\cite{StromY86}.
Typestate analysis attaches a finite-state machine (FSM)
to each program element of a given type, and transitions the state of the
FSM whenever a relevant operation is performed.
In an accumulation analysis,
the order of operations performed cannot change what is subsequently
permitted, and executing more operations cannot add additional
restrictions.  If it is applicable, accumulation analysis provides a major
benefit over general typestate analysis: it does not
require a whole-program alias analysis for soundness.
Hence, we can build a sound, modular must-call
checker without doing \emph{any} whole-program alias analysis.
Accumulation also enables a clean design, as we
can conceptually factor our checker into a sound core, and
then enhance it with
targeted alias reasoning to reduce false positives.

Unlike recent work on accumulation~\cite{KelloggRSSE2020}, we found
that checking resource leaks precisely requires significantly more
reasoning about aliasing patterns.  We found several key patterns to
handle:
\begin{itemize}
\item passing of resources via parameters or returns;
\item storing of resources in final fields, in a standard RAII manner~\cite{raii};
\item wrapper types, which share their must-call obligations with one of their fields; and,
\item storing resources in non-final fields, which might be lazily initialized or
  written more than once.
\end{itemize}
We devised three key techniques to handle these patterns modularly
and achieve precision in practice:
\begin{itemize}
\item a lightweight, heuristic ownership transfer system. This system
  indicates which reference is responsible for resolving a must-call
  obligation. Unlike typical ownership type systems, our approach does
  not impact the privileges of other references.
\item resource aliasing, for cases in which a resource's must-call obligations
  can be resolved by closing one of two or more references.
\item \emph{accumulation frames}, an extension to the theory of
  accumulation analysis which allow for ``resetting'' the must-call state
  of a reference to handle lazy or multiple initialization.
\end{itemize}
Variants of (some of) these ideas exist in previous work.  We bring
them together in a general, modular manner, with full verification and
the ability for programmers to easily extend checking to their own
types and must-call properties.

Our contributions are:
\begin{itemize}
\item the insight that the resource leak problem is an accumulation
  problem, and
  % a novel set of
  type systems designed to take advantage
  of this fact (\cref{sec:base-type-systems}).
\item three
  % novel
  innovations that improve the precision of our type
  systems: a lightweight ownership tracking system
  (\cref{sec:lightweight-ownership}), a lightweight resource-alias
  tracking analysis (\cref{sec:must-call-choice}), and an extension to
  accumulation analysis (\cref{sec:reset-must-call}).
\item an open-source implementation for Java,
  called \Tool (\cref{sec:implementation}).
\item an extensive empirical evaluation: case studies on heavily-used
  Java programs that handle many resources (\cref{sec:case-studies}),
  an ablation study that shows the contributions of each innovation to
  \Tool's precision (\cref{sec:ablation}), and a comparison to
  other state-of-the-art approaches that demonstrates the unique strengths
  of our approach (\cref{sec:compare}).
%% \item a comparison to alternative approaches to resource leak
%%   checking, that demonstrates that our approach occupies a unique
%%   point in the design space: faster and more usable than heavy-weight
%%   typestate systems, but sound and able to find even subtle bugs,
%%   unlike heuristic bug-finders (\cref{sec:compare}).
\end{itemize}
  

% LocalWords:  unmanaged leakable finalizers RAII
