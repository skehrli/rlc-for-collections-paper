\section{Related Work}
\label{sec:relatedwork}

\subsection{Resource leak detection}
\label{sec:rw-resource-leaks}

\todo{Do a literature search on this topic, and add anything pertinent to
  the below.}

\todo{Re-organize and edit the below in a way that makes sense.}

\subsubsection{Static analysis}

Tracker~\cite{TorlakC10} uses a dataflow analysis over the control-flow
graph to reason about resource leaks, while avoiding the problem of
whole-program alias analysis using an access-path approach. Like our tool,
it scales to large Java programs; unlike \tool, however, it is unsound.

Grapple~\cite{zuo2019grapple} models alias and dataflow analyses as
dynamic transitive-closure computation of graph representations of
the target programs, enabling extraordinary precision with a whole-program
alias analysis. Compared to \tool, it is more precise but suffers
from unsoundness and an order of magnitude longer run times.
We compare directly to Grapple in \cref{sec:grapple}.

The Eclipse Compiler for Java includes a simple dataflow-based
bug-finder for resource leaks~\cite{ecj-resource-leak}. Their analysis
uses a fixed set of ownership heuristics and a fixed list of wrapper
classes; unlike \tool, it is also unsound. It is fast and
\todo{possibly} precise.  Similar analyses---with similar trade-offs
compared to \tool---are present in other heuristic bug-finding tools,
including SpotBugs~\cite{spotbugs-resource-leak},
PMD~\cite{pmd-resource-leak}, Infer~\cite{infer-resource-leak}, and others.
We compare to the Eclipse analysis directly in \cref{sec:eclipse}.

Weimer and Necula~\cite{WeimerN04} proposed a language feature called
a compensation stack to avoid resource leak problems in Java.

Relda and Relda2~\cite{guo2013characterizing,wu2016relda2} are unsound
resource-leak detection approaches that are augmented with call graphs
to model the Android framework's use of callbacks for releasing
resources.

The DroidLeaks benchmark~\cite{liu2019droidleaks} is a set of Android
apps with known resource leak bugs. Unfortunately, it includes only
the compiled apps, not the source code, so we were unable to run \tool
on its contents (\tool requires source code as its input).

The CLOSER~\cite{dillig2008closer} automatically inserts Java code to
dispose of resources when they are no longer ``live'' according to its
dataflow analysis, but requires an expensive alias analysis for
soundness, as well as manually-provided aliasing specifications for
linked libraries.

\todo{This~\cite{ghanavati2020memory} is a recent study on what kinds
  of resource and memory leak bugs happen in large Java projects. I'm
  sure we can use it somewhere.}

\subsubsection{Dynamic analysis}

Resco~\cite{dai2013resco} operates similarly to a garbage collector,
tracking resources whose program elements have become
unreachable. When a given resource (such as file descriptors) is close
to exhaustion, the runtime runs Resco to clean up any resources of
that type that are unreachable.  With a static approach such as ours,
a tool like Resco becomes unnecessary---leaks become impossible.

Automated test generation can also be used to try to detect resource
leaks. For example, leaks in Android applications can be found by
repeatedly running neutral---eventually returning to the same
state---GUI actions~\cite{wu2018sentinel,zhang2016automated}.
Other techniques focus on taking advantage of common misuse of
the Android activity lifecycle~\cite{amalfitano2020memories}.
Testing can only show the presence of bugs, not their absence;
\tool verifies that no resource leaks are present.

\subsection{Ownership tracking}

\todo{Manu: Describe relationship to rust's borrow checker.}

\todo{Is there other relevant related work? Find out.}

\subsection{Typestate analysis}
\label{sec:rw-typestate}

\tool relies on an accumulation
analysis~\cite{KelloggRSSE2020,FahndrichLeino03} to avoid the need
for a whole-program alias analysis, while retaining soundness.  We
build on the core analysis described in~\cite{KelloggRSSE2020},
adding the concept of accumulation frames.

Accumulation analysis is a special-case of typestate analysis~\cite{StromY86}.
In general, a typestate analysis requires a whole-program alias analysis
for soundness, making them impractical for resource leak detection
in industrial-size Java programs. \todo{However, people have probably tried
  so go figure that out.}

An alternative to applying a typestate analysis to an existing program
is to rewrite the program in a typestate-oriented programming
language~\cite{AldrichSSS2009}. \todo{Aldrich's group probably has a
  paper about doing resource leak detection in Plaid, so find and cite
  that here.}
