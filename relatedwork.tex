\section{Related Work}
\label{sec:relatedwork}

\subsection{Resource leak detection}
\label{sec:rw-resource-leaks}

\todo{Do a literature search on this topic, and add anything pertinent to
  the below.}

\todo{Re-organize and edit the below in a way that makes sense.}

\subsubsection{Static analysis}

Tracker~\cite{TorlakC10} uses a dataflow analysis over the control-flow
graph to reason about resource leaks, while avoiding the problem of
whole-program alias analysis using an access-path approach. Like our tool,
it scales to large Java programs; unlike \Tool, however, it is unsound.

Grapple~\cite{zuo2019grapple} models alias and dataflow analyses as
dynamic transitive-closure computation of graph representations of
the target programs, enabling extraordinary precision with a whole-program
alias analysis. Compared to \Tool, it is more precise but suffers
from unsoundness and an order of magnitude longer run times.
We compare directly to Grapple in \cref{sec:grapple}.

The Eclipse Compiler for Java includes a simple dataflow-based
bug-finder for resource leaks~\cite{ecj-resource-leak}. Their analysis
uses a fixed set of ownership heuristics and a fixed list of wrapper
classes; unlike \Tool, it is also unsound. It is fast and
\todo{possibly} precise.  Similar analyses---with similar trade-offs
compared to \Tool---are present in other heuristic bug-finding tools,
including SpotBugs~\cite{spotbugs-resource-leak},
PMD~\cite{pmd-resource-leak}, Infer~\cite{infer-resource-leak}, and others.
We compare to the Eclipse analysis directly in \cref{sec:eclipse}.

Weimer and Necula~\cite{WeimerN04} proposed a language feature called
a compensation stack to avoid resource leak problems in Java.

Relda and Relda2~\cite{guo2013characterizing,wu2016relda2} are unsound
resource-leak detection approaches that are augmented with call graphs
to model the Android framework's use of callbacks for releasing
resources.

The DroidLeaks benchmark~\cite{liu2019droidleaks} is a set of Android
apps with known resource leak bugs. Unfortunately, it includes only
the compiled apps, not the source code, so we were unable to run \Tool
on its contents (\Tool requires source code as its input).

The CLOSER~\cite{dillig2008closer} automatically inserts Java code to
dispose of resources when they are no longer ``live'' according to its
dataflow analysis, but requires an expensive alias analysis for
soundness, as well as manually-provided aliasing specifications for
linked libraries.

\todo{This~\cite{ghanavati2020memory} is a recent study on what kinds
  of resource and memory leak bugs happen in large Java projects. I'm
  sure we can use it somewhere.}

\subsubsection{Dynamic analysis}

Resco~\cite{dai2013resco} operates similarly to a garbage collector,
tracking resources whose program elements have become
unreachable. When a given resource (such as file descriptors) is close
to exhaustion, the runtime runs Resco to clean up any resources of
that type that are unreachable.  With a static approach such as ours,
a tool like Resco becomes unnecessary---leaks become impossible.

Automated test generation can also be used to try to detect resource
leaks. For example, leaks in Android applications can be found by
repeatedly running neutral---eventually returning to the same
state---GUI actions~\cite{wu2018sentinel,zhang2016automated}.
Other techniques focus on taking advantage of common misuse of
the Android activity lifecycle~\cite{amalfitano2020memories}.
Testing can only show the presence of bugs, not their absence;
\Tool verifies that no resource leaks are present.

\subsection{Ownership tracking in Rust}

Ownership type systems generally impose control over aliasing, which in turn
enables guaranteeing other high-level properties, like absence of resource
leaks.  We do not discuss the vast literature on ownership type systems here
(see Clarke et al.~\cite{clarke2013ownership} for a survey).  Instead, we focus
on ownership types in Rust~\cite{klabnik2018rust} as the most popular
practical example of using ownership to prevent resource leaks.

For a detailed overview of ownership in Rust, see Chapter 4
of~\cite{klabnik2018rust}; we give a brief overview here.  In Rust, ownership is
used to manage both memory and other resources.  Every value associated with a
resource must have a \emph{unique} owning pointer, and when an owning pointer's
lifetime ends, the value is ``dropped,'' ensuring all resources are freed.  The
power of Rust's ownership type system is that it not only statically prevents
resource leaks, but also other important issues like ``double-free'' bugs
(releasing a resource more than once) and ``use-after-free'' bugs (using a
resource after it has been released). However, this power comes with a cost; to
enforce uniqueness, non-owning pointers must be invalidated after an assignment,
and can no longer be used to perform any operations.  Maintaining multiple
usable pointers to a value requires use of language features like references and
borrowing, and even then, borrowed pointers have restricted privileges.

\Tool has less power than Rust's ownership types; it cannot prevent resources
from being closed multiple times or being used after they are closed.  However,
\Tool's lightweight ownership annotations impose \emph{no} restrictions on
aliasing; they are simply an aid to help the tool identify how a resource will
be closed.  Hence, lightweight ownership is much better suited to preventing
resource leaks in existing, large Java code bases; adapting such programs to use
a full Rust-style ownership type system would be an enormous and impractical
undertaking.

%\todo{Is there other relevant related work? Find out.}

%\todo{We may want to cite RAII (\url{https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization}) and
%state that our handling of owning fields can verify it.}

\subsection{Typestate analysis}
\label{sec:rw-typestate}

\Tool relies on an accumulation
analysis~\cite{KelloggRSSE2020,FahndrichLeino03} to avoid the need
for a whole-program alias analysis, while retaining soundness.  We
build on the core analysis described in~\cite{KelloggRSSE2020},
adding the concept of accumulation frames.

Accumulation analysis is a special-case of typestate analysis~\cite{StromY86}.
In general, a typestate analysis requires a whole-program alias analysis
for soundness, making them impractical for resource leak detection
in industrial-size Java programs. \todo{However, people have probably tried
  so go figure that out.}

An alternative to applying a typestate analysis to an existing program
is to rewrite the program in a typestate-oriented programming
language~\cite{AldrichSSS2009}. \todo{Aldrich's group probably has a
  paper about doing resource leak detection in Plaid, so find and cite
that here.}  \todo{Honestly I don't know that they do; I've looked at a few and
never saw anything about leak detection.  --Manu}
