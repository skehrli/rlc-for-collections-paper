\section{Related Work}
\label{sec:relatedwork}

Previous work on resource leak detection has typically been based on either
using program analysis to detect leaks or adding language features to prevent
them. Here we discuss the most relevant work from each of these categories.

\subsection{Analysis-based approaches}\label{sec:rw-analysis}

%\todo{Re-organize and edit the below in a way that makes sense.}

\paragraph{Static analysis}
Tracker~\cite{TorlakC10} performs inter-procedural dataflow analysis to detect
resource leaks, with various additional features to make their tool practical,
including issue prioritization and handling of wrapper types.  Tracker avoids
whole-program alias analysis to improve scalability, instead using a local,
access-path-based approach.  While Tracker scales well to large programs, it is
deliberately unsound, unlike \Tool.

The Eclipse Compiler for Java includes a simple dataflow-based
bug-finder for resource leaks~\cite{ecj-resource-leak}. Their analysis
uses a fixed set of ownership heuristics and a fixed list of wrapper
classes; unlike \Tool, it is unsound. It is fast.  Similar analyses---with similar trade-offs
compared to \Tool---are present in other heuristic bug-finding tools,
including SpotBugs~\cite{spotbugs-resource-leak},
PMD~\cite{pmd-resource-leak}, and Infer~\cite{infer-resource-leak}.
\Cref{sec:eclipse} experimentally evaluates the Eclipse analysis.

Typestate analysis~\cite{StromY86,FinkYDRG2008} can be used to
find resource leaks.  Grapple~\cite{zuo2019grapple} is the most recent system to
use this approach, leveraging a disk-based graph engine to achieve unprecedented
scalability on a single machine.  Compared to \Tool, Grapple is more precise but suffers
from unsoundness and much longer run times.
\Cref{sec:grapple} gives a more detailed comparison to Grapple.

Relda and Relda2~\cite{guo2013characterizing,wu2016relda2} are unsound
resource-leak detection approaches \todo{similar to Eclipse,then?} that are
augmented with call graphs to model the Android framework's use of callbacks for
releasing resources.

The CLOSER~\cite{dillig2008closer} automatically inserts Java code to dispose of
resources when they are no longer ``live'' according to its dataflow analysis.
Their approach requires an expensive alias analysis for soundness, as well as
manually-provided aliasing specifications for linked libraries.
\todo{\Tool requires that too, though only lightweight specifications.
  Mention that?}
\Tool uses accumulation
analysis~\cite{KelloggRSSE2020,FahndrichLeino03} to achieve soundness without
the need
for a whole-program alias analysis.
We
build on the core analysis described in~\cite{KelloggRSSE2020},
adding the concept of accumulation frames.

\paragraph{Dynamic analysis}
Some approaches use dynamic analysis to ameliorate leaks.  Resco \cite{dai2013resco}
operates similarly to a garbage collector, tracking resources whose program
elements have become unreachable. When a given resource (such as file
descriptors) is close to exhaustion, the runtime runs Resco to clean up any
resources of that type that are unreachable.  With a static approach such as
ours, a tool like Resco becomes unnecessary---leaks become impossible.

Automated test generation can also be used to try to detect resource
leaks. For example, leaks in Android applications can be found by
repeatedly running neutral---eventually returning to the same
state---GUI actions~\cite{wu2018sentinel,zhang2016automated}.
Other techniques focus on taking advantage of common misuse of
the Android activity lifecycle~\cite{amalfitano2020memories}.
Testing can only show the presence of bugs, not their absence;
\Tool verifies that no resource leaks are present.

\paragraph{Data sets and surveys}
In terms of data sets for leak detection, The DroidLeaks
benchmark~\cite{liu2019droidleaks} is a set of Android apps with known resource
leak bugs. Unfortunately, it includes only the compiled apps.
\Tool runs on source code, so we were unable to run \Tool on DroidLeaks.

\todo{This~\cite{ghanavati2020memory} is a recent study on what kinds
  of resource and memory leak bugs happen in large Java projects. I'm
  sure we can use it somewhere.}



\subsection{Language-based approaches}\label{sec:rw-language}

\paragraph{Ownership types and Rust} Ownership type
systems~\cite{clarke2013ownership} impose control over aliasing, which
in turn enables guaranteeing other high-level properties, like absence of
resource leaks.  We do not discuss the vast literature on ownership type systems
here (see Clarke et al.~\cite{clarke2013ownership} for a survey). Instead, we
focus on ownership types in Rust~\cite{klabnik2018rust} as the most popular
practical example of using ownership to prevent resource leaks.

For a detailed overview of ownership in Rust, see Chapter 4
of~\cite{klabnik2018rust}; we give a brief overview here.  In Rust, ownership is
used to manage both memory and other resources.  Every value associated with a
resource must have a \emph{unique} owning pointer, and when an owning pointer's
lifetime ends, the value is ``dropped,'' ensuring all resources are freed.
Rust's ownership type system statically prevents
not only resource leaks, but also other important issues like ``double-free'' bugs
(releasing a resource more than once) and ``use-after-free'' bugs (using a
resource after it has been released). However, this power comes with a cost; to
enforce uniqueness, non-owning pointers must be invalidated after an assignment,
and can no longer be used to perform any operations.  Maintaining multiple
usable pointers to a value requires use of language features like references and
borrowing, and even then, borrowed pointers have restricted privileges.

\Tool has less power than Rust's ownership types; it cannot prevent resources
from being closed multiple times or being used after they are closed.  However,
\Tool's lightweight ownership annotations impose \emph{no} restrictions on
aliasing; they are simply an aid to help the tool identify how a resource will
be closed.  Hence, lightweight ownership is much better suited to preventing
resource leaks in existing, large Java code bases; adapting such programs to use
a full Rust-style ownership type system would be an enormous and impractical
undertaking.

\paragraph{Other approaches} Compensation stacks~\cite{WeimerN04}
generalize C++ destructors and Java's
try-with-resources, to avoid resource leak problems in Java.  While
compensation stacks make resource leaks less likely, they do not provide a
guarantee that leaks will not occur, unlike \Tool.

An alternative to applying a typestate analysis to an existing program
is to rewrite the program in a typestate-oriented programming
language~\cite{AldrichSSS2009,garcia2014typestate}.  The type systems of such
languages are expressive enough to prevent resource leaks, but they impose
restrictions on aliasing and a high type annotation burden, making translation
of existing code impractical.

%\todo{Is there other relevant related work? Find out.}

%\todo{We may want to cite RAII (\url{https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization}) and
%state that our handling of owning fields can verify it.}



% Accumulation analysis is a special-case of typestate analysis~\cite{StromY86}.
% In general, a typestate analysis requires a whole-program alias analysis
% for soundness, making them impractical for resource leak detection
% in industrial-size Java programs. \todo{However, people have probably tried
%   so go figure that out.}

% LocalWords:  Relda Relda2 Resco runtime DroidLeaks
