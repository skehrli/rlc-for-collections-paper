\section{Related Work}
\label{sec:relatedwork}

Most prior work on resource leak detection either uses
program analysis to detect leaks or adds language features to prevent
them. Here we focus on the most relevant work from these categories.\looseness=-1

\subsection{Analysis-based approaches}\label{sec:rw-analysis}

%\todo{Re-organize and edit the below in a way that makes sense.}

\paragraph{Static analysis}
Tracker~\cite{TorlakC10} performs inter-procedural dataflow analysis to detect
resource leaks, with various additional features to make their tool practical,
including issue prioritization and handling of wrapper types.  Tracker avoids
whole-program alias analysis to improve scalability, instead using a local,
access-path-based approach.  While Tracker scales well to large programs, it is
deliberately unsound, unlike \tool.

The Eclipse Compiler for Java includes a dataflow-based
bug-finder for resource leaks~\cite{ecj-resource-leak}. Its analysis
uses a fixed set of ownership heuristics and a fixed list of wrapper
classes; unlike \tool, it is unsound. It is fast.  Similar analyses---with similar trade-offs
compared to \tool---exist in other heuristic bug-finding tools,
including SpotBugs~\cite{spotbugs-resource-leak},
PMD~\cite{pmd-resource-leak}, and Infer~\cite{infer-resource-leak}.
\Cref{sec:eclipse} experimentally evaluates the Eclipse analysis.
Relda and Relda2~\cite{guo2013characterizing,wu2016relda2} are unsound
resource-leak detection approaches that are specialized to the Android framework
with call graphs that model the framework's use of callbacks for
releasing resources.

Typestate analysis~\cite{StromY86,FinkYDRG2008} can be used to
find resource leaks.  Grapple~\cite{zuo2019grapple} is the most recent system to
use this approach, leveraging a disk-based graph engine to achieve unprecedented
scalability on a single machine.  Compared to \tool, Grapple
is more precise but
suffers from unsoundness and much longer run times.
\Cref{sec:grapple} gives a more detailed comparison to Grapple.

The CLOSER~\cite{dillig2008closer} automatically inserts Java code to
dispose of resources when they are no longer ``live'' according to its
dataflow analysis.  Their approach requires an expensive alias
analysis for soundness, as well as manually-provided aliasing
specifications for linked libraries.\todo{\Tool requires that too,
  though only lightweight specifications.  Mention that?} \Tool uses
accumulation analysis~\cite{KelloggRSSE2020,FahndrichLeino03} to
achieve soundness without the need for a whole-program alias analysis.
We build on the core analysis described in~\cite{KelloggRSSE2020}.

\paragraph{Dynamic analysis}
Some approaches use dynamic analysis to ameliorate leaks.  Resco \cite{dai2013resco}
operates similarly to a garbage collector, tracking resources whose program
elements have become unreachable. When a given resource (such as file
descriptors) is close to exhaustion, the runtime runs Resco to clean up any
resources of that type that are unreachable.  With a static approach such as
ours, a tool like Resco becomes unnecessary---leaks become impossible.

Automated test generation can also be used to try to detect resource
leaks. For example, leaks in Android applications can be found by
repeatedly running neutral---i.e. eventually returning to the same
state---GUI actions~\cite{wu2018sentinel,zhang2016automated}.
Other techniques focus on taking advantage of common misuse of
the Android activity lifecycle~\cite{amalfitano2020memories}.
Testing can only show the presence of bugs, not their absence;
\tool verifies that no resource leaks are present.

\paragraph{Data sets and surveys}
The DroidLeaks
benchmark~\cite{liu2019droidleaks} is a set of Android apps with known resource
leak bugs. Unfortunately, it includes only the compiled apps. \Tool runs on
source code, so we were unable to run \tool on DroidLeaks. Ghanavati et
al.~\cite{ghanavati2020memory} performed a detailed recent study of resource
leaks and their repairs in Java projects, showing the pressing need for better
tooling for resource leak prevention.

\subsection{Language-based approaches}\label{sec:rw-language}

\paragraph{Ownership types and Rust} Ownership type
systems~\cite{clarke2013ownership} impose control over aliasing, which
in turn enables guaranteeing other high-level properties, like absence of
resource leaks.  We do not discuss the vast literature on ownership type systems
here (see Clarke et al.~\cite{clarke2013ownership} for a survey). Instead, we
focus on ownership types in Rust~\cite{klabnik2018rust} as the most popular
practical example of using ownership to prevent resource leaks.

For a detailed overview of ownership in Rust, see chapter 4
of~\cite{klabnik2018rust}; we give a brief overview here.  In Rust, ownership is
used to manage both memory and other resources.  Every value associated with a
resource must have a \emph{unique} owning pointer, and when an owning pointer's
lifetime ends, the value is ``dropped,'' ensuring all resources are freed.
Rust's ownership type system statically prevents
not only resource leaks, but also other important issues like ``double-free'' bugs
(releasing a resource more than once) and ``use-after-free'' bugs (using a
resource after it has been released). But, this power comes with a cost; to
enforce uniqueness, non-owning pointers must be invalidated after an ownership transfer,
and can no longer be used.  Maintaining multiple
usable pointers to a value requires use of language features like references and
borrowing, and even then, borrowed pointers have restricted privileges.

\Tool has less power than Rust's ownership types; it cannot prevent double-free
or use-after-free bugs.  But,
\tool's lightweight ownership annotations impose \emph{no} restrictions on
aliasing; they simply aid the tool in identifying how a resource will
be closed.  Lightweight ownership is better suited to preventing
resource leaks in existing, large Java code bases; adapting such programs to use
a full Rust-style ownership type system would be impractical.\looseness=-1

\paragraph{Other approaches} Java's try-with-resources
construct~\cite{try-with-resources} was discussed in \cref{sec:intro}.  Java
also provides finalizer methods~\cite[Chapter 12]{gosling2014jls}, which execute before an object is
garbage-collected, but they should not be used for resource management, as their
execution may be delayed arbitrarily.

Compensation stacks~\cite{WeimerN04} generalize C++ destructors and Java's
try-with-resources, to avoid resource leak problems in Java.  While
compensation stacks make resource leaks less likely, they do not provide a
guarantee that leaks will not occur, unlike \tool.

Previous work has performed modular typestate analysis for annotated Java
programs~\cite{BierhoffA2007} or proposed typestate-oriented programming
languages that include modular typestate
checking~\cite{AldrichSSS2009,garcia2014typestate}.  The type systems of these
approaches are richer than those proposed here and can express arbitrary
typestate properties, beyond what can be checked with \tool.
However, these systems impose restrictions on aliasing and a
higher type annotation burden than \tool, making adoption for existing code
more challenging.

%\todo{Is there other relevant related work? Find out.}

%\todo{We may want to cite RAII (\url{https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization}) and
%state that our handling of owning fields can verify it.}



% Accumulation analysis is a special-case of typestate analysis~\cite{StromY86}.
% In general, a typestate analysis requires a whole-program alias analysis
% for soundness, making them impractical for resource leak detection
% in industrial-size Java programs. \todo{However, people have probably tried
%   so go figure that out.}

% LocalWords:  Relda Relda2 Resco runtime DroidLeaks
