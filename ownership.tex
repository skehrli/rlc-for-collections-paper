\section{Lightweight ownership transfer}
\label{sec:lightweight-ownership}

%% MK: I think this is taken care of.
%% \todo{I suggest that throughout this section (including in the title), we
%%   rename ``lightweight ownership tracking'' to ``lightweight ownership
%%   transfer''.  Our system doesn't really \emph{track} ownership so much as
%%   \emph{transfer} it.  Though I guess what is really being transferred is
%%   MustCall obligations, so maybe that fact can inspire better naming.  Just
%%   ``lightweight ownership'' is a bit too vague for my tastes, but I think
%%   it is at least better than ``lightweight ownership tracking''.}


\Cref{sec:base-type-systems} describes a sound accumulation-based
checker for resource leaks. However, that checker often encounters false
positives in cases where a \MustCall obligation is satisfied
in another procedure via parameter passing, return values, or object fields.
Consider the following code that safely closes a \<Socket>:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  void example(String myHost, int myPort) {
    Socket s = new Socket(myHost, myPort);
    closeSocket(s);
  }
  void closeSocket(@Owning @MustCall("close") Socket t) {
    t.close();
  }  
\end{lstlisting}

The \<closeSocket()> routine takes ownership of the socket---that is,
it takes responsibility for closing it. The checker described by
\cref{sec:base-type-systems} would issue a false positive on this
code, because it would warn when \<s>
goes out of scope at the end of \<example()>.
% With the \<@Owning> annotation on the parameter to \<closeSocket>,
% however, the checker can determine that \<closeSocket> is the correct
% place to check.

This section describes a \emph{lightweight ownership transfer} technique for reducing
false positives in such cases.
Programmers write annotations like \<@Owning> that transfer an
obligation from one expression to another.
Programmer
annotations \emph{cannot} introduce any checker unsoundness; at worst,
incorrect \<@Owning> annotations will cause false positive warnings.
Unlike an ownership type system like Rust's (see \cref{sec:rw-language}),
lightweight ownership transfer imposes no restrictions on what operations can be performed
through an alias, and hence has a minimal impact on the programming model.

\subsection{Ownership transfer}
\label{sec:ownership-transfer}

\<@Owning> is a declaration annotation, not a type qualifier; it can be
written on a declaration such as a parameter, return, field, etc., but not
on a type.
A pseudo-assignment to an \<@Owning> lvalue transfers the right-hand side's
\MustCall obligation.
More concretely, in the Must Call Consistency Checker
(\cref{sec:must-call-invoked}), at a pseudo-assignment to an lvalue with
an \<@Owning> annotation, the right-hand side's
\MustCall obligation is treated as satisfied.

The \textsc{MCSatisfiedAfter}$(P,s)$ and \textsc{HasObligation}$(e)$ procedures 
of \cref{alg:helpers} are enhanced for ownership transfer as follows:
\begin{algorithmic}
  \Procedure{MCSatisfiedAfter}{$P,s$}
  \State \Return $\exists p \in P .\ \textsc{MCAfter}(p,s) \subseteq \textsc{CMAfter}(p,s)$ \newline
  \hspace*{6em} $\vee\ (s \mathrm{\ is\ } \mathtt{return\ p} \wedge \textsc{OwningReturn}(CFG))$ \newline
  \hspace*{6em} $\vee\ \textsc{PassedAsOwningParam}(s,p)$\newline
  \hspace*{6em} $\vee\ (s \mathrm{\ is\ } \mathtt{q.f\ =\ p} \wedge \mathtt{f} \mathrm{\ is\ } \mathtt{@Owning})$
  \EndProcedure
  \Procedure{HasObligation}{$e$}
  \State \Return $e$ has a declared \MustCall type and $e$'s declaration is \<@Owning>
  \EndProcedure
  \Procedure{OwningReturn}{$CFG$}
  \State \Return $CFG$'s return declaration is \<@Owning>
  \EndProcedure
  \Procedure{PassedAsOwningParam}{s,p}
  \State \Return $s$ passes $p$ to an \<@Owning> parameter of its callee
  \EndProcedure
\end{algorithmic}
\Cref{sec:owning-fields} discusses checking of \<@Owning> fields.
% These relatively simple changes are all that
% is required to add lightweight ownership tracking to our technique.\todo{but we
% didn't discuss fields yet...}

Constructor returns are always \<@Owning>.
\Tool's default for unannotated method returns is \<@Owning>,
and for unannotated parameters and fields is \<@NotOwning>.  These assumptions
coincide well with coding patterns we observed in practice, reducing the
annotation burden for programmers.  Further, this treatment of parameter and
return types ensures sound handling of unannotated third-party libraries: any
object returned from such a library is tracked by default, and the checker
never assumes that passing an object to an unannotated library satisfies its obligations.

%% This paragraph doesn't seem to add much -- the first part is redundant and
%% the second part is vacuous (or at least better situated in a future work section).
% Programmers can override defaults by writing explicit \<@Owning> or
% \<@NotOwning> annotations on method returns, parameters, and fields (though never both at the same
% location---they are mutually exclusive).    Such explicit annotations can
% \emph{never} compromise soundness.  If such an annotation is incorrect (e.g., an
% \<@Owning> annotation on a reference that does not satisfy an obligation), it
% can only lead to false positives, not false negatives.  Due to this design,
% there is great scope for creating inference techniques for lightweight
% ownership, to further reduce annotation burden; we plan to pursue such
% techniques in future work.
% \todo{pointer to further discussion in evaluation?}


\subsection{Final owning fields}
\label{sec:owning-fields}

  Additional class-level checking is required for \<@Owning>
  fields, as the code
  satisfying their \MustCall obligations usually spans multiple
  procedures.  This section handles final fields,\footnote{\Tool
    treats all static fields as non-owning, meaning that no assignment to one
    can satisfy a must-call obligation. In our case studies, we did
    not observe any assignments of expressions with non-empty must-call obligations
    to static fields. We leave handling owning static fields to future work.
  }
  which cannot be overwritten after initialization of the enclosing
  object.  When checking
  non-final fields, the checker must ensure
  that overwriting the field is safe
  %does not lead to an unsatisfied \MustCall obligation.
  (see \Cref{sec:non-final-owning}).

  For final fields, our checking enforces the ``resource acquisition is
  initialization (RAII)'' programming idiom~\cite{raii}.  Some
  destructor-like method \<d()> must ensure the field's \MustCall obligation is
  satisfied, and the enclosing class must have a \MustCall\<("d")> obligation to
  ensure the destructor is called.

  More formally, consider a final \<@Owning> field $f$ declared in class $C$,
  where
  $f$ has type \MustCall\<("m")>.  To modularly
  verify that $f$'s \MustCall obligation is satisfied, \tool checks the following
  conditions:
  \begin{enumerate}
    \item All $C$ objects must have a type \MustCall\<("d")> for some method \<C.d()>.
    \item \<C.d()> must always invoke \<this.f.m()>, thereby satisfying $f$'s
    \MustCall obligation.
  \end{enumerate}
  Condition 1 is checked by inspecting the \<@MustCall> annotation on class $C$.
  Condition 2 is checked by requiring an appropriate \EnsuresCalledMethods
  postcondition annotation on \<C.d()>, which is then enforced by the Called
  Methods Checker~\cite{KelloggRSSE2020}.



% LocalWords:  MustCall belowskip myHost myPort closeSocket NotOwning RAII
% LocalWords:  MCSatisfied MCBefore CMBefore MCReturn EnsuresCalledMethods
% LocalWords:  lvalue MCSatisfiedAfter HasObligation destructor
