\section{Lightweight ownership tracking}
\label{sec:lightweight-ownership}

\Cref{sec:base-type-systems} describes a sound accumulation-based
checker for resource leaks. However, that checker often encounters false
positives caused by cases where a \<@MustCall> obligation is satisfied
in another procedure via parameter passing, return values, or object fields.
Consider the following code that safely closes a \<Socket>:
\todo{I think the formal parameter \<t> should be annotated as \<@MustCall("close")>.}

\begin{lstlisting}[frame=tb,belowskip=3mm]
  void example(String myHost, int myPort) {
    Socket s = new Socket(myHost, myPort);
    closeSocket(s);
  }
  void closeSocket(@Owning Socket t) {
    t.close();
  }  
\end{lstlisting}

The \<closeSocket()> routine takes ownership of the socket---that is,
it takes responsibility for closing it. The checker described by
\cref{sec:base-type-systems} would issue a false positive on this
code, because it would warn when \<s>
goes out of scope in \<closeSocket()>.
% With the \<@Owning> annotation on the parameter to \<closeSocket>,
% however, the checker can determine that \<closeSocket> is the correct
% place to check.

This section describes a \emph{lightweight ownership tracking} technique for reducing
false positives in such cases.  With lightweight ownership, programmer
annotations \emph{cannot} introduce any checker unsoundness; they can only
reduce false positives.  Further, unlike other ownership type systems\todo{cite},
lightweight ownership imposes no restriction on what operations can be performed
through an alias, and hence has a minimal impact on the programming model.

\subsection{Ownership transfer}
\label{sec:ownership-transfer}

With lightweight ownership, a parameter, return, or field type may be annotated
as either \<@Owning> or \<@NotOwning>.
\todo{If this is a type system, state the type hierarchy.  It's not clear
  whether this is actually a declaration annotation, however.  Please
  clarify.  If it's a type system, then every type has (not ``may have'')
  an \<@Owning> or \<@NotOwning> qualifier.}
In the Must Call Consistency Checker
(\Cref{sec:must-call-invoked}), if a tracked variable $p$ is assigned to such an
\<@Owning> location $l$, $p$'s
\<@MustCall> obligation is treated as satisfied. Assume\todo{Remove their
  description from here and put the two helper functions in the algorithmic
  snippet.} we have a helper
function $\textsc{OwningReturn}(CFG)$ that checks if the return type of $CFG$'s
method is \<@Owning>, and $\textsc{PassedAsOwningParam}(s,p)$ that checks if $s$ is a
call that passes $p$ to an \<@Owning> parameter of the callee.  Then,
\textsc{MCSatisfiedAfter}$(P,s)$ of \Cref{alg:helpers} is enhanced to handle
ownership transfer as follows:

% \begin{align*}
%   \exists p \in P &.\ \textsc{MCBefore}(p,s) \subseteq \textsc{CMBefore(p,s)}\\
%                   &\vee (s \mathrm{\ is\ } \mathtt{return\ p} \wedge \mathrm{method\ return\ type\ is\ } \mathtt{@Owning})\\
%                   &\vee (s \mathrm{\ is\ } \mathtt{q\ =\ foo(...,p,...)} \wedge \mathtt{p} \mathrm{\ is\ } \mathtt{@Owning})\\
%                   &\vee (s \mathrm{\ is\ } \mathtt{q.f\ =\ p} \wedge \mathtt{f} \mathrm{\ is\ } \mathtt{@Owning})\\
% \end{align*}
\begin{algorithmic}
  \Procedure{MCSatisfiedAfter}{$P,s$}
  \State \Return $\exists p \in P .\ \textsc{MCAfter}(p,s) \subseteq \textsc{CMAfter}(p,s)$ \newline
  \hspace*{6em} $\vee\ (s \mathrm{\ is\ } \mathtt{return\ p} \wedge \textsc{OwningReturn}(CFG))$ \newline
  \hspace*{6em} $\vee\ \textsc{PassedAsOwningParam}(s,p)$\newline
  \hspace*{6em} $\vee\ (s \mathrm{\ is\ } \mathtt{q.f\ =\ p} \wedge \mathtt{f} \mathrm{\ is\ } \mathtt{@Owning})$
  \EndProcedure

\end{algorithmic}

To ensure soundness, the analysis must ensure that the \<@MustCall> obligation
of any \<@Owning> location is satisfied.  For returns and parameters, we simply
enhance the \textsc{HasObligation} routine of \Cref{alg:helpers} to check for
ownership:
\todo{I'm not sure what ``$e$ is \<@Owning>'' means.  A type is \<@Owning>
  or not (if \<@Owning> is a type qualifier}, but we cannot say that of an expression.}
\begin{algorithmic}
  \Procedure{HasObligation}{$e$}
  \State \Return $e$ has a declared \<@MustCall> type and $e$ is \<@Owning>
  \EndProcedure
\end{algorithmic}
\Cref{sec:owning-fields} discusses checking of \<@Owning> fields.
% These relatively simple changes are all that
% is required to add lightweight ownership tracking to our technique.\todo{but we
% didn't discuss fields yet...}

\Tool's default for unannotated return types is \<@Owning>,
and for unannotated parameter and field types is \<@NotOwning>.  These assumptions
coincide well with coding patterns we observed in practice, reducing the
annotation burden for programmers.  Further, this treatment of parameter and
return types ensures sound handling of unannotated third-party libraries: any
object returned from such a library will be tracked by default, and the checker
never assumes that passing an object to a library will satisfy its obligation.

Programmers can override defaults by writing explicit \<@Owning> or
\<@NotOwning> annotations on method returns, parameters, and fields (though never both at the same
location---they are mutually exclusive).  (Note that constructor returns are always
\<@Owning>.)  Such explicit annotations can
\emph{never} compromise soundness.  If such an annotation is incorrect (e.g., an
\<@Owning> annotation on a reference that does not satisfy an obligation), it
can only lead to false positives, not false negatives.  Due to this design,
there is great scope for creating inference techniques for lightweight
ownership, to further reduce annotation burden; we plan to pursue such
techniques in future work.
\todo{pointer to further discussion in evaluation?}

\todo{Add a para comparing to Rust ownership and the like?}

\subsection{Final owning fields}
\label{sec:owning-fields}

  Additional class-level checking is required for \<@Owning>
  fields\todo{There are only \<@Owning>
  fields if \<@Owning>
  is a declaration annotation.  Or should this be ``fields of \<@Owning> type''?}, as the code
  satisfying their \<@MustCall> obligations nearly always spans multiple
  procedures.  We first discuss the case of final fields,\footnote{We only
  consider instance fields in this paper; we have not observed resource leaks
  through static fields in our benchmarks, and we leave their handling to future
  work.} which cannot be overwritten after initialization of the enclosing
  object.  Here, our checking enforces the "resource acquisition is
  initialization (RAII)" programming idiom~\cite{raii}; a distinguished
  ``destructor''-like method \<d()> must ensure the field's \<@MustCall> obligation is
  satisfied, and the enclosing class must have a \<@MustCall("d")> obligation to
  ensure the destructor is called.

  More formally, consider a final \<@Owning> field $f$ declared in class $C$,
  where
  $f$ has type \<@MustCall("m")>.  To
  verify that $f$'s \<@MustCall> obligation is satisfied, we check the following
  conditions:
  \begin{enumerate}
    \item All $C$ objects must have a type \<@MustCall("d")> for some method \<C.d()>.
    \item \<C.d()> must always invoke \<this.f.m()>, thereby satisfying $f$'s
    \<@MustCall> obligation.
  \end{enumerate}
  In this manner, we modularly verify the \<@MustCall> obligaation of $f$.  Condition 2 is
  checked by requiring an appropriate \<@EnsuresCalledMethods> annotation on
  \<C.d()>, which is then enforced by the Called Methods
  Checker~\cite{KelloggRSSE2020}.  \todo{this all needs an example...} 

  While this scheme suffices for verifying final fields, we observed cases
  in our benchmarks of non-final fields with \<@MustCall> obligations.  Checking
  non-final fields requires additional techniques, as the checker must ensure
  that overwriting the field does not lead to an unsatisfied \<@MustCall> obligation.  We
  describe our novel handling of non-final fields in \Cref{sec:reset-must-call}.


% LocalWords:  MustCall belowskip myHost myPort closeSocket NotOwning
% LocalWords:  MCSatisfied MCBefore CMBefore MCReturn EnsuresCalledMethods
