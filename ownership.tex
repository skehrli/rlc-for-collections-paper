\section{Lightweight ownership tracking}
\label{sec:lightweight-ownership}

For the basic technique described in \Cref{sec:base-type-systems}, false
positives are often caused by cases where a \<@MustCall> obligation is satisfied
in another procedure, via parameter passing, return values, or object fields.
Here, we describe a \emph{lightweight ownership tracking} technique for reducing
false positives in such cases.  With lightweight ownership, programmer
annotations \emph{cannot} introduce any checker unsoundness; they can only to
reduce false positives.  Further, unlike other ownership type systems,
lightweight ownership imposes no restriction on what operations can be performed
through an alias, and hence has a minimal impact on the programming model.

% We developed two novel approaches for tracking whether a pointer is
% owning: a lightweight ownership transfer approach using annotations
% that does not depend on the annotations' correctness---that is, adding
% ownership annotations can only reduce false positives, not false
% negatives (\cref{sec:ownership-transfer})---and a lightweight, local
% alias analysis for dealing with wrapper objects
% (\cref{sec:must-call-choice}).

\todo{maybe \<@MustCallChoice> belongs in its own section?  no longer sure it fits with ownership}
We also describe a lightweight, local alias analysis for dealing with wrapper
objects (\Cref{sec:must-call-choice}).

\subsection{Ownership transfer}
\label{sec:ownership-transfer}

% \todo{Write about @Owning and @NotOwning, and show how they can only
%   reduce false positives.}

With lightweight ownership, a parameter, return, or field type may be annotated
as either \<@Owning> or \<@NotOwning> (we shall discuss defaults shortly).  In
the Must Call Consistency Checker (\Cref{sec:must-call-invoked}), if a tracked
variable $p$ is assigned to such an \<@Owning> location $l$, we \emph{transfer}
ownership to $l$, and $p$'s \<@MustCall> obligation
is treated as satisfied. Specifically, the condition checked by
\textsc{MCSatisfied}$(P,s)$ of \Cref{alg:helpers} is modified as follows
\todo{sloppy, make it better}:

\begin{align*}
  \exists p \in P &.\ \textsc{MCBefore}(p,s) \subseteq \textsc{CMBefore(p,s)}\\
                  &\vee (s \mathrm{\ is\ } \mathtt{return\ p} \wedge \mathrm{method\ return\ type\ is\ } \mathtt{@Owning})\\
                  &\vee (s \mathrm{\ is\ } \mathtt{q\ =\ foo(...,p,...)} \wedge \mathrm{param\ type\ is\ } \mathtt{@Owning})\\
                  &\vee (s \mathrm{\ is\ } \mathtt{q.f\ =\ p} \wedge \mathtt{f} \mathrm{\ is\ } \mathtt{@Owning})\\
\end{align*}

To ensure soundness, any \<@Owning> location must be tracked to ensure its
\<@MustCall> obligation is satisfied.  We shall discuss checking of \<@Owning>
fields in \Cref{sec:owning-fields}.  For \<@Owning> method returns, we need only
update the \textsc{HasMCReturn} routine used in \Cref{alg:helpers} to check that
the return type both has a non-empty \<@MustCall> obligation \emph{and} is
\<@Owning>.  For \<@Owning> parameters, the loop at
Lines~\ref{li:start-init}--\ref{li:end-init} in \Cref{alg:consistency-checker}
must be extended to also add each \<@Owning> formal parameter as a dataflow
fact at the entry node of the CFG.  These relatively simple changes are all that
is required to add lightweight ownership tracking to our technique.

By default, our checker assumes that unannotated return types are \<@Owning>,
but that parameter and field types are \<@NotOwning>.  These assumptions
coincide well with coding patterns we observed in practice, reducing the
programmer annotation burden.  Further, this treatment of parameter and return
types ensures sound handling of unannotated third-party libraries: any object
returned from such a library will be tracked by default, and the checker never
assumes that passing an object to a library will satisfy its obligation.

Programmers can override defaults by writing explicit \<@Owning> and
\<@NotOwning> annotations.  Such explicit annotations can \emph{never}
compromise soundness.  If such an annotation is incorrect (e.g., an \<@Owning>
annotation on a reference that does not satisfy an obligation), it can only lead
to false positives, not false negatives.  Due to this design, there is great
scope for creating inference techniques for lightweight ownership, to further
reduce annotation burden; we plan to pursue such techniques in future work.

\todo{Add a para comparing to Rust ownership and the like?}

\subsubsection{Final owning fields}
\label{sec:owning-fields}

\todo{This section should cover the rules for final owning fields. Non-final
  owning fields are covered by \cref{sec:reset-must-call}, and this
  section is referred to from there.}

  Additional class-level checking is required for \<@Owning> fields, as the code
  satisfying their \<@MustCall> obligations nearly always spans multiple
  procedures.  We first discuss the case of final fields,\footnote{We only
  consider instance fields in this paper; we have not observed resource leaks
  through static fields in our benchmarks, and we leave their handling to future
  work.} which cannot be overwritten after initialization of the enclosing
  object.  Consider a final \<@Owning> field $f$ declared in class $C$, where
  $f$ has type \<@MustCall("m")>.  To
  verify that $f$'s \<@MustCall> obligation is satisfied, we check the following
  conditions:
  \begin{enumerate}
    \item $C$ objects must have a type \<@MustCall("n")> for some method $C.n$.
    \item $C.n$ must always invoke \<this.f.m()>, thereby satisfying $f$'s
    \<@MustCall> obligation.
  \end{enumerate}
  In this manner, we compositionally verify the usage of $f$, by imposing
  a \<@MustCall> obligation on clients using the $C$ class.  Condition 2 can be
  checked by requiring an appropriate \<@EnsuresCalledMethods> annotation on
  $C.n$, which is then enforced by the Called Methods
  Checker~\cite{kellogg20verifying}.  \todo{this all needs an example...}

  While this scheme suffices for verifying final fields, we observed many cases
  in our benchmarks of non-final fields with \<@MustCall> obligations.  Checking
  non-final fields requires additional techniques, as the checker must ensure
  that overwriting the field does not lead to a \<@MustCall> violation.  We
  describe our novel handling of non-final fields in \Cref{sec:reset-must-call}.

\subsection{Lightweight alias analysis for wrapper types}
\label{sec:must-call-choice}

The Java standard library contains a number of \emph{wrapper types}:
classes that wrap a resource variable that might contain a resource.
For example, consider the class \<java.io.BufferedOutputStream>.  The
must-call obligation for an arbitrary \<BufferedOutputStream> is
\<@MustCall(\{``close''\})>---the stream might be writing to a file,
for example.  \<BufferedOutputStream>'s constructors all have a
parameter which is another \<OutputStream>. When \<close()> is called
on the resulting \<BufferedOutputStream>, the implementation calls
\<close()> on the wrapped \<OutputStream>. Since there are no
additional resources allocated by the \<BufferedOutputStream> that
were not part of the \<OutputStream> passed to the constructor,
calling \<close()> on either stream is equally correct (though most
Java style guides suggest calling \<close()> on the outermost
wrapper \todo{cite that claim?}).

Code that uses these streams usually calls \<close()> on only one
of the streams---either the wrapper stream or the wrapped stream.
A tool that reported an error for one stream if the other was closed
would report too many false positives to be usable in practice.
Prior work uses a pre-determined list of wrapper classes, built into
the tool, to handle this issue~\cite{TorlakC10}. \todo{Also cite ecj here?
  I think it also uses the same scheme...}

Our approach is more general. We introduce a new type qualifier,
\<@MustCallChoice>, to represent the wrapper relationship. \<@MustCallChoice>
qualifiers must always appear in pairs---one on a parameter of a method,
and another on its return type.

A pair of \<@MustCallChoice> annotations has two effects, in different
checkers:
\begin{itemize}
\item the Must Call Checker treats the annotated elements as polymorphic---the
  must-call obligations of the parameter are copied to the return type.
  Therefore, if the wrapped type has no must-call obligations (such as
  for a stream definitely wrapping a byte array), the wrapper will not
  have must-call obligations, either.
\item the Ownership Checker will treat the pair of streams as aliases,
  for the purposes of resolving must-call obligations. Therefore, calling
  \<close()> on one stream will be treated as calling \<close()> on both.
\end{itemize}

A pair of \<@MustCallChoice> annotations can be verified (though our current
implementation does not do so, since almost all appear in the standard
library rather than checked code) \todo{fix this!}. There are two
procedures to check
that a pair of \<@MustCallChoice> annotations on a method \<m>'s return type
and its parameter \<p>:
\begin{enumerate}
\item if \<p> is passed to another method or constructor in an
  \<@MustCallChoice> position, and \<m> returns the result of that method
  (or the method is a \<super()> constructor call appropriately annotated
  with \<@MustCallChoice>), then the code can be verified.
\item if \<p> is stored in an \<@Owning> field of the class, and the
  class declaration has an \<@MustCall(>$A$\<)> annotation for some set
  of methods $A$, and at least one of the methods in $A$ has an
  \<@EnsuresCalledMethods> annotation naming at least the
  must-call obligations of \<p>'s static type, then the code can be verified.
\end{enumerate}

Using \<@MustCallChoice> has another benefit: must-call obligations
can be shared even by objects that cannot possibly fulfill the
obligation. For example, consider the method
\<java.io.RandomAccessFile\#getFd()>, which returns a file descriptor
object for the file owned by the \<RandomAccessFile>. This file
descriptor cannot be closed directly---it has no \<close()> method.
However, it can be passed to a wrapper stream, such as
\<java.io.FileOutputStream>---which can be closed, fulfilling
the original must-call obligation. By creating a chain of \<@MustCallChoice>
annotations, we can verify code like the below:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  RandomAccessFile file = new RandomAccessFile(myFile, "rws");
  FileInputStream in = null;
  try {
    in = new FileInputStream(file.getFD());
    // do something with in  
    in.close();
  } catch (IOException e){
    file.close();
  }
\end{lstlisting}
