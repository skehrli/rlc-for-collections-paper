\section{Lightweight ownership tracking}
\label{sec:lightweight-ownership}

\Cref{sec:base-type-systems} describes a sound accumulation-based
checker for resource leaks. However, that checker often encounters false
positives caused by cases where a \<@MustCall> obligation is satisfied
in another procedure, via parameter passing, return values, or object fields.
For example, consider the following code that safely closes a \<Socket>:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  void example(String myHost, int myPort) {
    Socket s = new Socket(myHost, myPort);
    closeSocket(s);
  }
  void closeSocket(@Owning Socket s) {
    s.close();
  }  
\end{lstlisting}

The \<closeSocket()> routine takes ownership of the socket---that is,
it takes responsibility for closing it. The correct place for our
checker to enforce that \<close()> has been called on \<s> is not
when \<s> goes out of scope in \<example()>, but rather when \<s>
goes out of scope in \<closeSocket()>. The checker described by
\cref{sec:base-type-systems} would issue a false positive on this
code, because it would warn about \<example>'s pointer to \<s>.
With the \<@Owning> annotation on the parameter to \<closeSocket>,
however, the checker can determine that \<closeSocket> is the correct
place to check.

Here, we describe a \emph{lightweight ownership tracking} technique for reducing
false positives in such cases.  With lightweight ownership, programmer
annotations \emph{cannot} introduce any checker unsoundness; they can only to
reduce false positives.  Further, unlike other ownership type systems~\todo{cite},
lightweight ownership imposes no restriction on what operations can be performed
through an alias, and hence has a minimal impact on the programming model.

\subsection{Ownership transfer}
\label{sec:ownership-transfer}

With lightweight ownership, a parameter, return, or field type may be annotated
as either \<@Owning> or \<@NotOwning>.  In the Must Call Consistency Checker
(\Cref{sec:must-call-invoked}), if a tracked variable $p$ is assigned to such an
\<@Owning> location $l$, we \emph{transfer} ownership to $l$, and $p$'s
\<@MustCall> obligation is treated as satisfied. Assume we have a helper
function $\textsc{OwningReturn}(CFG)$ that checks if the return type of $CFG$'s
method is \<@Owning>, and $\textsc{PassedAsOwningParam}(s,p)$ that checks if $s$ is a
call that passes $p$ to an \<@Owning> parameter of the callee.  Then,
\textsc{MCSatisfied}$(P,s)$ of \Cref{alg:helpers} is enhanced to handle
ownership transfer as follows:

% \begin{align*}
%   \exists p \in P &.\ \textsc{MCBefore}(p,s) \subseteq \textsc{CMBefore(p,s)}\\
%                   &\vee (s \mathrm{\ is\ } \mathtt{return\ p} \wedge \mathrm{method\ return\ type\ is\ } \mathtt{@Owning})\\
%                   &\vee (s \mathrm{\ is\ } \mathtt{q\ =\ foo(...,p,...)} \wedge \mathtt{p} \mathrm{\ is\ } \mathtt{@Owning})\\
%                   &\vee (s \mathrm{\ is\ } \mathtt{q.f\ =\ p} \wedge \mathtt{f} \mathrm{\ is\ } \mathtt{@Owning})\\
% \end{align*}
\begin{algorithmic}
  \Procedure{MCSatisfied}{$P,s$}
  \State \Return $\exists p \in P .\ \textsc{MCAfter}(p,s) \subseteq \textsc{CMAfter}(p,s)$ \newline
  \hspace*{6em} $\vee\ (s \mathrm{\ is\ } \mathtt{return\ p} \wedge \textsc{OwningReturn}(CFG))$ \newline
  \hspace*{6em} $\vee\ \textsc{PassedAsOwningParam}(s,p)$\newline
  \hspace*{6em} $\vee\ (s \mathrm{\ is\ } \mathtt{q.f\ =\ p} \wedge \mathtt{f} \mathrm{\ is\ } \mathtt{@Owning})$
  \EndProcedure

\end{algorithmic}

To ensure soundness, the analysis must ensure that the \<@MustCall> obligation
of any \<@Owning> location is satisfied.  We discuss checking of \<@Owning>
fields in \Cref{sec:owning-fields}.  For \<@Owning> method returns, we need only
update the \textsc{Has\-MCReturn} routine used in \Cref{alg:helpers} to check that
the return type both has a non-empty \<@MustCall> obligation \emph{and} is
\<@Owning>.  For \<@Owning> parameters, the loop at
Lines~\ref{li:start-init}--\ref{li:end-init} in \Cref{alg:consistency-checker}
must be extended to also add each \<@Owning> formal parameter as a dataflow
fact at the entry node of the CFG.  These relatively simple changes are all that
is required to add lightweight ownership tracking to our technique.\todo{but we
didn't discuss fields yet...}

By default, our checker assumes that unannotated return types are \<@Owning>,
but that parameter and field types are \<@NotOwning>.  These assumptions
coincide well with coding patterns we observed in practice, reducing the
annotation burden for programmers.  Further, this treatment of parameter and
return types ensures sound handling of unannotated third-party libraries: any
object returned from such a library will be tracked by default, and the checker
never assumes that passing an object to a library will satisfy its obligation.

Programmers can override defaults by writing explicit \<@Owning> or
\<@NotOwning> annotations on method returns (constructors are always
\<@Owning>), parameters, and fields (though never both at the same
location---they are mutually exclusive).  Such explicit annotations can
\emph{never} compromise soundness.  If such an annotation is incorrect (e.g., an
\<@Owning> annotation on a reference that does not satisfy an obligation), it
can only lead to false positives, not false negatives.  Due to this design,
there is great scope for creating inference techniques for lightweight
ownership, to further reduce annotation burden; we plan to pursue such
techniques in future work.
\todo{pointer to further discussion in evaluation?}

\todo{Add a para comparing to Rust ownership and the like?}

\subsection{Final owning fields}
\label{sec:owning-fields}

  Additional class-level checking is required for \<@Owning> fields, as the code
  satisfying their \<@MustCall> obligations nearly always spans multiple
  procedures.  We first discuss the case of final fields,\footnote{We only
  consider instance fields in this paper; we have not observed resource leaks
  through static fields in our benchmarks, and we leave their handling to future
  work.} which cannot be overwritten after initialization of the enclosing
  object.  Consider a final \<@Owning> field $f$ declared in class $C$, where
  $f$ has type \<@MustCall("m")>.  To
  verify that $f$'s \<@MustCall> obligation is satisfied, we check the following
  conditions:
  \begin{enumerate}
    \item All $C$ objects must have a type \<@MustCall("n")> for some method $C.n$.
    \item $C.n$ must always invoke \<this.f.m()>, thereby satisfying $f$'s
    \<@MustCall> obligation.
  \end{enumerate}
  In this manner, we verify the usage of $f$, by imposing
  a \<@MustCall> obligation on clients using the $C$ class.  Condition 2 is
  checked by requiring an appropriate \<@EnsuresCalledMethods> annotation on
  $C.n$, which is then enforced by the Called Methods
  Checker~\cite{KelloggRSSE2020}.  \todo{this all needs an example...} \todo{Mention RAII}

  While this scheme suffices for verifying final fields, we observed many cases
  in our benchmarks of non-final fields with \<@MustCall> obligations.  Checking
  non-final fields requires additional techniques, as the checker must ensure
  that overwriting the field does not lead to a \<@MustCall> violation.  We
  describe our novel handling of non-final fields in \Cref{sec:reset-must-call}.


% LocalWords:  MustCall belowskip myHost myPort closeSocket NotOwning
% LocalWords:  MCSatisfied MCBefore CMBefore MCReturn EnsuresCalledMethods
