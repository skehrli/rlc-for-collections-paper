\section{Lightweight ownership tracking}
\label{sec:lightweight-ownership}

For the basic technique described in \Cref{sec:base-type-systems}, false
positives are often caused by cases where a \<@MustCall> obligation is satisfied
in another procedure, via parameter passing, return values, or object fields.
Here, we describe a \emph{lightweight ownership tracking} technique for reducing
false positives in such cases.  With lightweight ownership, programmer
annotations \emph{cannot} introduce any checker unsoundness; they can only to
reduce false positives.  Further, unlike other ownership type systems,
lightweight ownership imposes no restriction on what operations can be performed
through an alias, and hence has a minimal impact on the programming model.

% We developed two novel approaches for tracking whether a pointer is
% owning: a lightweight ownership transfer approach using annotations
% that does not depend on the annotations' correctness---that is, adding
% ownership annotations can only reduce false positives, not false
% negatives (\cref{sec:ownership-transfer})---and a lightweight, local
% alias analysis for dealing with wrapper objects
% (\cref{sec:must-call-choice}).

\todo{maybe \mccannot belongs in its own section?  no longer sure it fits with ownership}
We also describe a lightweight, local alias analysis for dealing with wrapper
objects (\Cref{sec:must-call-choice}).

\subsection{Ownership transfer}
\label{sec:ownership-transfer}

% \todo{Write about @Owning and @NotOwning, and show how they can only
%   reduce false positives.}

With lightweight ownership, a parameter, return, or field type may be annotated
as either \<@Owning> or \<@NotOwning> (we shall discuss default assumptions for
these annotations shortly).  In
the Must Call Consistency Checker (\Cref{sec:must-call-invoked}), if a tracked
variable $p$ is assigned to such an \<@Owning> location $l$, we \emph{transfer}
ownership to $l$, and $p$'s \<@MustCall> obligation
is treated as satisfied. Specifically, the condition checked by
\textsc{MCSatisfied}$(P,s)$ of \Cref{alg:helpers} is enhanced as follows
\todo{sloppy, make it better}:

\begin{align*}
  \exists p \in P &.\ \textsc{MCBefore}(p,s) \subseteq \textsc{CMBefore(p,s)}\\
                  &\vee (s \mathrm{\ is\ } \mathtt{return\ p} \wedge \mathrm{method\ return\ type\ is\ } \mathtt{@Owning})\\
                  &\vee (s \mathrm{\ is\ } \mathtt{q\ =\ foo(...,p,...)} \wedge \mathrm{param\ type\ is\ } \mathtt{@Owning})\\
                  &\vee (s \mathrm{\ is\ } \mathtt{q.f\ =\ p} \wedge \mathtt{f} \mathrm{\ is\ } \mathtt{@Owning})\\
\end{align*}

To ensure soundness, the analysis must ensure that the \<@MustCall> obligation
of any \<@Owning> location is satisfied.  We discuss checking of \<@Owning>
fields in \Cref{sec:owning-fields}.  For \<@Owning> method returns, we need only
update the \textsc{Has\-MCReturn} routine used in \Cref{alg:helpers} to check that
the return type both has a non-empty \<@MustCall> obligation \emph{and} is
\<@Owning>.  For \<@Owning> parameters, the loop at
Lines~\ref{li:start-init}--\ref{li:end-init} in \Cref{alg:consistency-checker}
must be extended to also add each \<@Owning> formal parameter as a dataflow
fact at the entry node of the CFG.  These relatively simple changes are all that
is required to add lightweight ownership tracking to our technique.\todo{but we
didn't discuss fields yet...}

By default, our checker assumes that unannotated return types are \<@Owning>,
but that parameter and field types are \<@NotOwning>.  These assumptions
coincide well with coding patterns we observed in practice, reducing the
annotation burden for programmers.  Further, this treatment of parameter and
return types ensures sound handling of unannotated third-party libraries: any
object returned from such a library will be tracked by default, and the checker
never assumes that passing an object to a library will satisfy its obligation.

Programmers can override defaults by writing explicit \<@Owning> and
\<@NotOwning> annotations.  Such explicit annotations can \emph{never}
compromise soundness.  If such an annotation is incorrect (e.g., an \<@Owning>
annotation on a reference that does not satisfy an obligation), it can only lead
to false positives, not false negatives.  Due to this design, there is great
scope for creating inference techniques for lightweight ownership, to further
reduce annotation burden; we plan to pursue such techniques in future work.
\todo{pointer to further discussion in evaluation?}

\todo{Add a para comparing to Rust ownership and the like?}

\subsubsection{Final owning fields}
\label{sec:owning-fields}

  Additional class-level checking is required for \<@Owning> fields, as the code
  satisfying their \<@MustCall> obligations nearly always spans multiple
  procedures.  We first discuss the case of final fields,\footnote{We only
  consider instance fields in this paper; we have not observed resource leaks
  through static fields in our benchmarks, and we leave their handling to future
  work.} which cannot be overwritten after initialization of the enclosing
  object.  Consider a final \<@Owning> field $f$ declared in class $C$, where
  $f$ has type \<@MustCall("m")>.  To
  verify that $f$'s \<@MustCall> obligation is satisfied, we check the following
  conditions:
  \begin{enumerate}
    \item All $C$ objects must have a type \<@MustCall("n")> for some method $C.n$.
    \item $C.n$ must always invoke \<this.f.m()>, thereby satisfying $f$'s
    \<@MustCall> obligation.
  \end{enumerate}
  In this manner, we compositionally verify the usage of $f$, by imposing
  a \<@MustCall> obligation on clients using the $C$ class.  Condition 2 can be
  checked by requiring an appropriate \<@EnsuresCalledMethods> annotation on
  $C.n$, which is then enforced by the Called Methods
  Checker~\cite{kellogg20verifying}.  \todo{this all needs an example...}

  While this scheme suffices for verifying final fields, we observed many cases
  in our benchmarks of non-final fields with \<@MustCall> obligations.  Checking
  non-final fields requires additional techniques, as the checker must ensure
  that overwriting the field does not lead to a \<@MustCall> violation.  We
  describe our novel handling of non-final fields in \Cref{sec:reset-must-call}.

\subsection{Wrapper types and must-call aliases}
\label{sec:must-call-choice}

Precise leak detection for Java requires reasoning about \emph{wrapper types},
which wrap another type that may contain a resource.  For example, the Java
\<BufferedOutputStream> type adds buffering to some other \<OutputStream>, which
may or may not represent a resource that needs closing.  Wrapper types
introduce two additional complexities for \<@MustCall> checking:
\begin{enumerate}
  \item If a wrapped object has no \<@MustCall> obligation, the corresponding
  wrapper object should also have no obligation.
  \item Satisfying the obligation of \emph{either} the wrapped object or the
  wrapper object is sufficient.
\end{enumerate}
For example, if a \<BufferedOutputStream> $b$ wraps a stream with no underlying
resource (e.g., a \<ByteArrayOutputStream>), $b$ should have an empty
\<@MustCall> obligation, since $b$ has no resource of its own.  On the other
hand, if $b$ wraps a stream managing a resource, like a \<FileOutputStream> $f$,
then \<close()> must be invoked on \emph{either} $b$ or $f$. Calling \<close()> on $b$
is sufficient since $b$\<.close()> invokes \<close()> on its wrapped stream $f$.

Previous work has shown that a reasoning about wrapper types is required to
avoid excessive false positive and duplicate reports~\cite{TorlakC10} \todo{cite
ECJ}.  Wrapper types in earlier work were handled with hard-coded specifications of
which library types are wrappers and also, in the work of Torlak and
Chandra~\cite{TorlakC10}, a clustering technique to group warnings involving a
resource and its wrappers.  

Our technique handles wrapper types more generally by tracking \emph{must-call
aliases} during analysis.  Two references $r_1$ and $r_2$ are must-call aliases
if satisfying $r_1$'s \<@MustCall> obligation also satisfies $r_2$'s
obligation, and vice-versa.  If $r_1$ and $r_2$ are must-aliased pointers, then
clearly they are also must-call aliases.  We also introduce a new type
qualifier \mccannot to indicate where an API method creates a must-call-alias
relationship between distinct objects, like a wrapper and the wrapped resource.
\mccannot can be used to annotate a \<BufferedOutputStream> constructor as follows:
\begin{lstlisting}
@MustCallAlias BufferedOutputStream(@MustCallAlias OutputStream arg0);
\end{lstlisting}

\mccannot qualifiers must always appear in pairs---one on a parameter of a
method, and another on its return type.  A pair of \mccannot annotations has two
effects on our inference and checking.  First, must-call obligation inference (\Cref{sec:must-call})
treats the annotated elements as polymorphic---the must-call obligations of the
parameter are copied to the return type. Therefore, if the wrapped type has no
must-call obligations (like a \<ByteArrayOutputStream>),
the wrapper will not have must-call obligations, either.

Second, at call sites, the Must Call Consistency Checker
(\Cref{sec:must-call-choice}) treats the \mccannot parameter and return as
aliases.  Specifically, the \textsc{CreatesAlias} routine in \cref{alg:helpers} is
modified as follows \todo{better notation!}:
\begin{algorithmic}
  \Procedure{CreatesAlias}{$P,s$}
    \State \Return $s$ is \lstinline{p = q} $\wedge\ q \in P$ \newline
         \hspace*{4.5em} $\vee$ $(s$ is \lstinline{p = foo(p1, p2, ...)} \newline
         \hspace*{6em} $\wedge\ \exists p_i \in P.\ q_i$ is
         \lstinline{@MustCallAlias} in \lstinline{foo})
    \EndProcedure
\end{algorithmic}
Beyond must-aliasing between local variables, the routine now treats the
assigned variable $p$ of a call statement as a new must-call alias if a tracked
variable in $P$ is passed to some \mccannot parameter.
With this change, \Cref{alg:consistency-checker} will treat the case of a
must-call alias exactly the same as a standard must alias.
% As shown in
% \cref{alg:consistency-checker}, the returned set is added to the set of tracked
% variables for a resource (\cref{li:compute-new-mc-aliases}), and the algorithm
% treats satisfaction of the \<@MustCall> obligation for any variable in the set
% as satisfying all the others.\todo{need another pass on this prose...}

\mccannot can also be employed in scenarios beyond direct wrapper types, a
capability not present in previous work.  In certain cases, a resource gets
shared between objects via an intermediate object that cannot directly close the
resource.  For example, \<java.io.RandomAccessFile> (which must be closed) has
a method \<getFd()> that returns a \<FileDescriptor>
object for the file. This file
descriptor cannot be closed directly---it has no \<close()> method.
However, the descriptor can be passed to a wrapper stream such as
\<FileOutputStream>, which if closed satisifies the original must-call
obligation.  By adding \mccannot annotations to the \<getFd()> method, our
technique can verify code like the below:
\begin{lstlisting}[frame=tb,belowskip=3mm]
  RandomAccessFile file = new RandomAccessFile(myFile, "rws");
  FileInputStream in = null;
  try {
    in = new FileInputStream(file.getFD());
    // do something with in  
    in.close();
  } catch (IOException e){
    file.close();
  }
\end{lstlisting}
We assign \<FileDescriptor> a special \<@MustCall(?)> type \todo{should we use
$\top$?} that cannot be satisfied by any calls.  We found this capability to be
useful for verifying multiple code patterns in our case studies.

\paragraph{Verification of \mccannot} \todo{another pass on this once we figure out if we can
implement} A pair of \mccannot annotations can be verified (though our current
implementation does not do so, since almost all appear in the standard
library rather than checked code) \todo{fix this!}. There are two
procedures to check
that a pair of \mccannot annotations on a method \<m>'s return type
and its parameter \<p>:
\begin{enumerate}
\item if \<p> is passed to another method or constructor in an
  \mccannot position, and \<m> returns the result of that method
  (or the method is a \<super()> constructor call appropriately annotated
  with \mccannot), then the code can be verified.
\item if \<p> is stored in an \<@Owning> field of the class, and the
  class declaration has an \<@MustCall(>$A$\<)> annotation for some set
  of methods $A$, and at least one of the methods in $A$ has an
  \<@EnsuresCalledMethods> annotation naming at least the
  must-call obligations of \<p>'s static type, then the code can be verified.
\end{enumerate}

% As noted in previous work, p
% The
% must-call obligation for an arbitrary \<BufferedOutputStream> is
% \<@MustCall(\{``close''\})>---the stream might be writing to a file,
% for example.  \<BufferedOutputStream>'s constructors all have a
% parameter which is another \<OutputStream>. When \<close()> is called
% on the resulting \<BufferedOutputStream>, the implementation calls
% \<close()> on the wrapped \<OutputStream>. Since there are no
% additional resources allocated by the \<BufferedOutputStream> that
% were not part of the \<OutputStream> passed to the constructor,
% calling \<close()> on either stream is equally correct (though most
% Java style guides suggest calling \<close()> on the outermost
% wrapper \todo{cite that claim?}).

% Code that uses these streams usually calls \<close()> on only one
% of the streams---either the wrapper stream or the wrapped stream.
% A tool that reported an error for one stream if the other was closed
% would report too many false positives to be usable in practice.
% Prior work uses a pre-determined list of wrapper classes, built into
% the tool, to handle this issue~\cite{TorlakC10}. \todo{Also cite ecj here?
%   I think it also uses the same scheme...}