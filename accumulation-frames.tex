\section{Creating new obligations}
\label{sec:reset-must-call}

Every constructor of a class that has must-call obligations
implicitly creates obligations for the newly-created object.
However, non-constructor methods may also create obligations
when re-assigning non-final, owning fields or allocating
new system-level resources.

This section describes a post-condition annotation,
\ResetMustCall, that can be written on a method
declaration and takes one argument (the \emph{target}), which
indicates for which in-scope program element an obligation is created.

At each call to a method annotated as \ResetMustCall, \Tool removes any
inferred Called Methods information about the target.
The inferred must-call methods for the target could also increase:
if the declared type of the target's default must-call type includes any
methods that are not in its the current must-call type, they are added.
Since \ResetMustCall annotations can only increase its target's obligations,
no verification for them is needed: placing them anywhere in the program is sound
(but may reduce precision).

The Must Call Consistency Checker treats calls to \ResetMustCall obligations
as creating a fresh obligation to check.  In terms of our \cref{sec:must-call-invoked} pseudocode,
assume we have a routine \textsc{COTargets}$(c)$ that returns a set of all
variables $p_i$ passed to a \ResetMustCall target parameter of the method
invoked by $c$.  Then, we can update the \textsc{FactsFromCall} procedure of
\cref{alg:helpers} to handle \ResetMustCall as follows:
\begin{algorithmic}
  \Procedure{FactsFromCall}{$s$}
  \State $p \gets s.LHS, c \gets s.RHS$
  \State \Return $\{ \langle \{ p_i \}, c \rangle\ |\ p_i \in \textsc{COTargets}(c) \}$ \newline
  \hspace*{5em} $\cup\ (\textsc{HasObligation}(c)$ ? $\{ \langle \{ p \}, c \rangle \}$ : $\emptyset)$
  \EndProcedure
  \end{algorithmic}
Additionally, if during analysis, we encounter a call to a \ResetMustCall
method on a variable $p \in P$, \Tool treats the \MustCall
obligation of $p$ as \emph{satisfied}.  I.e., we add one more
case to the extended \textsc{MCSatisfiedAfter} predicate given in
\cref{sec:ownership-transfer} ($[\ldots]$ stands for the cases shown previously):
\begin{algorithmic}
  \Procedure{MCSatisfiedAfter}{$P,s$}
  \State \Return $\exists p \in P .\ [\ldots] \vee p \in \textsc{RMCTargets}(s)$
  \EndProcedure
\end{algorithmic}
\noindent
This is sound since the checker creates a new obligation for calls to
\ResetMustCall methods, and the must-call obligation inference ensures the
\MustCall type for the target will have a \emph{superset} of any methods present
before the call.
There is one exception to this consistency check: if an \ResetMustCall
method is invoked within a method that also has an \ResetMustCall annotation
with the same target---thus imposing the obligation on its caller---then
the new obligation can be treated as satisfied immediately.

\subsection{Non-final, owning fields}
\label{sec:non-final-owning}

\ResetMustCall allows us to verify uses of non-final fields
that contain a resource, even if they are re-assigned. Consider
the following example:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  @MustCall("close") // default qualifier for uses of SocketContainer
  class SocketContainer {
    private @Owning Socket sock;
    public SocketContainer() { sock = ...; } 
    void close() { sock.close() };
    @CreateObligation("this")
    void reconnect() {
      if (!sock.isClosed()) {
        sock.close();
      }
      sock = ...;
    }
  }
\end{lstlisting}
In the lifetime of a \<SocketContainer> object, \<sock>
might be re-assigned arbitrarily-many times: once at each
call to \<reconnect()>. This code is safe, however: \<reconnect()>
ensures that \<sock> is closed before re-assigning it.

The checker must enforce two new rules to ensure that
re-assignments to non-final, owning fields like \<sock> in the example
above are sound:
\begin{itemize}
\item any method that re-assigns a non-final, owning field of an object
  must be annotated with an \ResetMustCall that targets that object.
\item when a non-final, owning field $f$ is re-assigned at statement $s$,
  its inferred \MustCall obligation must be contained in its \<@CalledMethods>
  type at the program point before $s$.
\end{itemize}
\noindent
The first rule ensures that \<close()> is called after the last call
to \<reconnect()>, and the second rule ensures that \<reconnect()>
safely closes \<sock> before re-assigning it. Because calling
a \ResetMustCall method like \<reconnect()> resets called-methods
inference, calls to \<close> before the last call to \<reconnect()>
are disregarded.

\subsection{Unconnected sockets}
\label{sec:unconnected-sockets}
\ResetMustCall can also handle cases where an object, when created,
does not actually allocate a resource---but it will allocate a resource
later in its lifecycle. Consider, for example, the no-argument constructor
to \<java.net.Socket>. This constructor does not actually allocate an
operating system-level socket, but instead just creates the container
object, which permits the programmer to e.g. set options which will be used
when creating the physical socket. When such a \<Socket> is created, it
initially has no must-call obligation; it is only when the \<Socket> is
actually connected via a call to a method such as \<bind()>
or \<connect()> that the must-call obligation is created.

If all \<Socket>s are treated as \MustCall\<(\{"close"\})>,
a false positive would be reported
in code such as the below, which operates on an unconnected socket
(simplified from real code in Apache Zookeeper~\todo{cite}):

\begin{lstlisting}[frame=tb,belowskip=3mm]
  static Socket createSocket() {
    Socket sock = new Socket();
    sock.setSoTimeout(...);
    return sock;
  }
\end{lstlisting}

The call to \<setSoTimeout> can throw a \<SocketException> if the
socket is actually connected when it is called. Using \ResetMustCall,
however, we can soundly show that this socket is not connected:
the type of the result of the no-argument constructor can be
treated as \<@MustCall(\{\})>, and \ResetMustCall annotations
on the methods that actually allocate the socket---\<connect()> or
\<bind()>---enforce that as soon as the socket is actually open,
it is treated as \<@MustCall("close")>.

% LocalWords:  belowskip MustCall SocketContainer sc ResetMustCall
% LocalWords:  RMCTargets MCObligations HasMCReturn MCSatisfied
% LocalWords:  createSocket setSoTimeout SocketException
