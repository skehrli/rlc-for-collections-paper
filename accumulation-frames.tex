\section{Accumulation frames}
\label{sec:reset-must-call}

This section describes an enhancement to the theory of accumulation
analysis that allows \Tool to verify non-final, owning fields
that contain one or more resources during their lifetime
(\cref{sec:non-final-owning}).
This approach is also useful for
removing another set of false positives caused by unconnected sockets
(\cref{sec:unconnected-sockets}).

\subsection{Non-final, owning fields}
\label{sec:non-final-owning}

The analyses we have described so far assume that a single program
element will control at most one resource while it is in scope:
they always issue an error if a non-final field is assigned an expression
that controls a resource.
In practice, however, this is not true---non-final fields
may be assigned resources. Consider, for example,
the following code:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  @MustCall("close")
  class SocketContainer {
    private @Owning Socket sock;
    public SocketContainer() { sock = ...; } 
    void close() { sock.close() };
    void reconnect() {
      if (!sock.isClosed()) {
        sock.close();
      }
      sock = ...;
    }
  }
\end{lstlisting}
In the lifetime of a \<SocketContainer> object, it might control any
number of resources, depending on the number of calls to
\<reconnect()>. In order to verify the code above (and uses of the
class), we need \emph{accumulation frames}---distinct regions of the program in
which a program element can be treated as the subject of an
accumulation analysis. At the boundary between each frame, we check
that 1) the obligations of the old frame are fulfilled, and 2)
reset the obligations of the object.

For example, consider the following use of the \<SocketContainer> class
above:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  SocketContainer sc = ...;
  sc.close()
  // frame boundary
  sc.reconnect();
  sc.close();
\end{lstlisting}
This code contains two accumulation frames: the first extends from the
constructor call to the first call to \<reconnect()>, and the second
extends from the call to \<reconnect()> (which creates another
obligation) to the end of the block. Because \<reconnect()> is guaranteed
to clean up the resources that it overwrites---note the call
to \<close()> in its implementation---this code is safe, even though \<sc>
corresponds to two different resources: one for each frame.

We introduce a new annotation, called \<@ResetMustCall>, to delineate
an accumulation frame. \<@ResetMustCall> is written on a method
declaration, and takes one argument (the \emph{target}), which
indicates to which in-scope program element the frame applies. The
definition for \<reconnect()> above would then become:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  class SocketContainer {
    ...
    @ResetMustCall("this")
    void reconnect() { ... }
  }
\end{lstlisting}
When an \<@ResetMustCall>
method is invoked, \Tool removes any
inferred Called Methods information about the target (\<sc> in the example).
This rule means that even if \<close()> has already been called on \<sc>
(as in the example)
when \<reconnect()>
is called, \<close()> must be called again---corresponding to the intuition
that a new accumulation frame ``resets'' the obligations of \<sc>.
The inferred must-call methods for \<sc> could also increase:
if the declared type of \<sc>'s default must-call type includes any
methods that are not in the current must-call type for \<sc>, they are added.
Since \<@ResetMustCall> annotations can only increase its target's obligations,
no verification for them is needed: placing them anywhere in the program is sound
(but may reduce precision).

The Must Call Consistency Checker treats calls to \<@ResetMustCall> obligations
as creating a fresh obligation to check, since they mark the beginning of a new
accumulation frame.  In terms of our pseudocode, assume we have a routine
\textsc{RMCTargets}$(s)$ that works as follows: if $s$ is a
statement invoking a \<@ResetMustCall> method $m$, \textsc{RMCTargets}$(s)$ returns
the actual parameters at $s$ corresponding to $m$'s \<@ResetMustCall> targets;
otherwise, it returns $\emptyset$.  Then, we can update the
\textsc{MCObligations} procedure of \Cref{alg:helpers} to handle
\<@ResetMustCall> as follows:
\begin{algorithmic}
  \Procedure{MCObligations}{$s$}
    \State $r \gets \textsc{RMCTargets}(s)$
    \If{$s$ is \lstinline{p = foo(...)} and \textsc{HasMCReturn}(\lstinline{foo})}
      \State $r \gets r \cup \{p\}$
    \EndIf
    \State \Return $r$
    \EndProcedure
\end{algorithmic}
Also, if during the data flow analysis, we encounter a call to a \<@ResetMustCall>
method on a tracked variable $v$, we treat the existing \<@MustCall>
obligation of $v$ as \emph{satisfied} before the call.  I.e., we add one more
case to the \textsc{MCSatisfied} predicate given in
\Cref{sec:ownership-transfer} ($[\ldots]$ stands for the previous cases):
\begin{align*}
  \exists p \in P &.\ [\ldots] \vee p \in \textsc{RMCTargets}(s)
\end{align*}
This is sound since the checker creates a new obligation for calls to
\<@ResetMustCall> methods, and the must-call obligation inference ensures the
\<@MustCall> type for the target will have a superset of any methods present
before the call.
There is one exception to this consistency check: if an \<@ResetMustCall>
method is invoked within a method that also has an \<@ResetMustCall> annotation
with the same target---thus imposing the obligation on its caller---then
the new obligation can be treated as satisfied immediately.

Finally, the checker must enforce two new rules to ensure that
re-assignments to non-final, owning fields like \<sock> in the example
above are sound:
\begin{itemize}
\item any method that re-assigns a non-final, owning field of an object
  must be annotated with an \<@ResetMustCall> that targets that object.
\item when a non-final, owning field $f$ is re-assigned at statement $s$, its \<@MustCall> obligation
must be satisfied before $s$ (i.e., $\textsc{MCBefore}(f,s) \subseteq
\textsc{CMBefore}(f,s)$, see \Cref{alg:helpers}).
\end{itemize}
\noindent
Together, these rules guarantee that any re-assignment to a non-final, owning
field (1) ends the current accumulation frame with the obligation fulfilled,
and (2) starts a new accumulation frame, with the obligation re-imposed on
the target at the caller.

\subsection{Unconnected sockets}
\label{sec:unconnected-sockets}
Accumulation frames can also handle cases where an object, when created,
does not actually allocate a resource---but it will allocate a resource
later in its lifecycle. Consider, for example, the no-argument constructor
to \<java.net.Socket>. This constructor does not actually allocate an
operating system-level socket, but instead just creates the container
object, which permits the programmer to e.g. set options which will be used
when creating the physical socket. When such a \<Socket> is created, it
initially has no must-call obligation; it is only when the \<Socket> is
actually connected that the must-call obligation is created.

If all \<Socket>s are treated as \<@MustCall(\{"close"\})>---that is,
without the accumulation frames described in this section---a false positive
would be reported
in code such as the below, which operates on an unconnected socket
(simplified from real code in Apache Zookeeper~\todo{cite}):

\begin{lstlisting}[frame=tb,belowskip=3mm]
  static Socket createSocket() {
    Socket sock = new Socket();
    sock.setSoTimeout(...);
    return sock;
  }
\end{lstlisting}

The call to \<setSoTimeout> can throw a \<SocketException> if the
socket is actually connected when it is called, so without an
accumulation frame our analysis would report a possible leak along
that path.  However, we can use an accumulation frame \emph{without an
  obligation}---i.e. in which the \<Socket> is \<@MustCall({})>---
that extends from the constructor call to a method that connects the
socket (such as \<connect()> or \<bind()>) to avoid this false
positive, by annotating those methods (in the definition of
\<java.net.Socket>) as \<@ResetMustCall("this")>.  When one of these
methods is then called on the \<Socket> in client code that is being
verified by \Tool, its inferred must-call obligations increase to include
\<close()>, because by default an arbitrary \<Socket>'s type is
\<@MustCall("close")>.

% LocalWords:  belowskip MustCall SocketContainer sc ResetMustCall
% LocalWords:  RMCTargets MCObligations HasMCReturn MCSatisfied
% LocalWords:  createSocket setSoTimeout SocketException
