\section{Creating new obligations}
\label{sec:reset-must-call}

Every constructor of a class that has must-call obligations
implicitly creates obligations for the newly-created object.
However, non-constructor methods may also create obligations
when re-assigning non-final, owning fields or allocating
new system-level resources.
A post-condition annotation,
\CreateObligation,
indicates for which expression an obligation is created.

At each call to a method annotated as \CreateObligation\<(>\|expr|\<)>, \Tool removes any
inferred Called Methods information about \|expr|, reverting to
the declared type of \|expr|.
% if the target's default must-call type includes any
% methods that are not in its the current must-call type, they are added.
Since a \CreateObligation annotation can only increase its target's obligations,
no verification for them is needed: placing them anywhere in the program is sound
(but may reduce precision).

When checking a call to a method annotated as
\CreateObligation\<(>\|expr|\<)>, the Must Call Consistency Checker
(1) treats the \MustCall
obligation of \|expr| as \emph{satisfied},
and (2) creates a fresh obligation to check.
%
In terms of our \cref{sec:must-call-invoked} pseudocode,
we can update the \textsc{FactsFromCall} and \textsc{MCSatisfiedAfter} procedures of
\cref{alg:helpers} to handle \CreateObligation as follows ($[\ldots]$ stands for the cases shown previously,
including those in \cref{sec:ownership-transfer}):
%\todo{I suggest putting the base code first and the addition with COTargets second.}
\begin{algorithmic}
  \Procedure{FactsFromCall}{$s$}
  \State $p \gets s.LHS, c \gets s.RHS$
  \State \Return $\{ \langle \{ p_i \}, c \rangle\ |\ p_i \in \textsc{COTargets}(c) \}$ \newline
  \hspace*{5em} $\cup\ (\textsc{HasObligation}(c)$ ? $\{ \langle \{ p \}, c \rangle \}$ : $\emptyset)$
  \EndProcedure
  \Procedure{MCSatisfiedAfter}{$P,s$}
  \State \Return $\exists p \in P .\ [\ldots] \vee p \in \textsc{COTargets}(s)$
  \EndProcedure
  \Procedure{COTargets}{$c$}
  \State \Return \{ $p_i$\ |\ $p_i$ passed to a \CreateObligation target for $c$'s callee \}
  \EndProcedure
\end{algorithmic}
\noindent
This change is sound since the checker creates a new obligation for calls to
\CreateObligation methods, and the must-call obligation checker (\cref{sec:must-call}) ensures the
\MustCall type for the target will have a \emph{superset} of any methods present
before the call.
There is one exception to this consistency check: if a \CreateObligation
method is invoked within a method that also has an \CreateObligation annotation
with the same target---thus imposing the obligation on its caller---then
the new obligation can be treated as satisfied immediately.

\subsection{Non-final, owning fields}
\label{sec:non-final-owning}

\CreateObligation allows \Tool to verify uses of non-final fields
that contain a resource, even if they are re-assigned. Consider
the following example:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  @MustCall("close") // default qualifier for uses of SocketContainer
  class SocketContainer {
    private @Owning Socket sock;
    public SocketContainer() { sock = ...; } 
    void close() { sock.close() };
    @CreateObligation("this")
    void reconnect() {
      if (!sock.isClosed()) {
        sock.close();
      }
      sock = ...;
    }
  }
\end{lstlisting}
In the lifetime of a \<SocketContainer> object, \<sock>
might be re-assigned arbitrarily many times: once at each
call to \<reconnect()>. This code is safe, however: \<reconnect()>
ensures that \<sock> is closed before re-assigning it.

\Tool must enforce two new rules to ensure that
re-assignments to non-final, owning fields like \<sock> in the example
above are sound:
\begin{itemize}
\item any method that re-assigns a non-final, owning field of an object
  must be annotated with an \CreateObligation annotation
  that targets that object.
\item when a non-final, owning field $f$ is re-assigned at statement $s$,
  its inferred \MustCall obligation must be contained in its \<@CalledMethods>
  type at the program point before $s$.
\end{itemize}
\noindent
The first rule ensures that \<close()> is called after the last call
to \<reconnect()>, and the second rule ensures that \<reconnect()>
safely closes \<sock> before re-assigning it. Because calling
an \CreateObligation method like \<reconnect()> resets called-methods
inference, calls to \<close> before the last call to \<reconnect()>
are disregarded.

\subsection{Unconnected sockets}
\label{sec:unconnected-sockets}
\CreateObligation can also handle cases where object creation
does not allocate a resource, but the object will allocate a resource
later in its lifecycle. Consider the no-argument constructor
to \<java.net.Socket>. This constructor does not allocate an
operating system-level socket, but instead just creates the container
object, which permits the programmer to e.g. set options which will be used
when creating the physical socket. When such a \<Socket> is created, it
initially has no must-call obligation; it is only when the \<Socket> is
actually connected via a call to a method such as \<bind()>
or \<connect()> that the must-call obligation is created.

If all \<Socket>s are treated as \MustCall\<(\{"close"\})>,
a false positive would be reported
in code such as the below, which operates on an unconnected socket
(simplified from real code in Apache Zookeeper~\cite{zookeeper-create-socket}):

\begin{lstlisting}[frame=tb,belowskip=3mm]
  static Socket createSocket() {
    Socket sock = new Socket();
    sock.setSoTimeout(...);
    return sock;
  }
\end{lstlisting}

\noindent
The call to \<setSoTimeout> can throw a \<SocketException> if the
socket is actually connected when it is called. Using \CreateObligation,
however, \Tool can soundly show that this socket is not connected:
the type of the result of the no-argument constructor can be
treated as \<@MustCall(\{\})>, and \CreateObligation annotations
on the methods that actually allocate the socket---\<connect()> or
\<bind()>---enforce that as soon as the socket is actually open,
it is treated as \<@MustCall("close")>.

% LocalWords:  belowskip MustCall SocketContainer sc CreateObligation expr
% LocalWords:  RMCTargets MCObligations HasMCReturn MCSatisfied COTargets
% LocalWords:  createSocket setSoTimeout SocketException FactsFromCall
% LocalWords:  MCSatisfiedAfter CreateObligation isClosed CalledMethods
