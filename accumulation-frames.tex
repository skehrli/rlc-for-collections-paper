\section{Accumulation frames}
\label{sec:reset-must-call}

\subsection{Non-final, owning fields}
\label{sec:non-final-owning}

The analyses we have described so far assume that a single program
element will control at most one resource while it is in scope.
In practice, however, this is not true. Consider, for example,
the following code:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  @MustCall("close")
  class SocketContainer {
    private @Owning Socket sock;
    public SocketContainer() { sock = ...; } 
    void close() { sock.close() };
    void reconnect() { sock.close(); sock = ...; }
  }
\end{lstlisting}

In the lifetime of a \<SocketContainer> object, it might control any
number of resources, depending on the number of calls to
\<reconnect()>. In order to verify the code above (and uses of the
class), we need \emph{accumulation frames}---distinct regions of the program in
which a program element can be treated as the subject of an
accumulation analysis. The important distinction between an analysis
with accumulation frames and a standard accumulation analysis is that
in the former a single program element can be treated as going out of
scope multiple times.

For example, consider the following use of the \<SocketContainer> class
above:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  SocketContainer sc = ...;
  sc.close();
  // frame boundary
  sc.reconnect();
  sc.close();
\end{lstlisting}

This code contains two accumulation frames: the first extends from the
constructor call to the first call to \<close()>, and the second
extends from the call to \<reconnect()> (which creates another
obligation) to the end of the block. In effect, we can treat \<sc> as
two different entirely separate program elements---one for each
accumulation frame.

We introduce a new annotation, called \<@ResetMustCall>, to delineate
an accumulation frame. \<@ResetMustCall> is written on a method
declaration, and takes one argument (the \emph{target}), which
indicates to which in-scope program element the frame applies. The
definition for \<reconnect()> above would then become:

\begin{lstlisting}[frame=tb,belowskip=3mm]
  class SocketContainer {
    ...
    @ResetMustCall("this")
    void reconnect() { sock.close(); sock = ...; }
  }
\end{lstlisting}

\todo{Martin: fix this for the Must Call Checker} When an \<@ResetMustCall>
method is invoked, the Must Call Checker and the Called Methods remove any
inferred information about the target, and restore it to the default value for
its type in their respective hierarchies \footnote{Note that according to the
rules in \cref{sec:owning-fields}, a class with an owning field must have a
\<@MustCall> annotation corresponding to a method that ensures the field's
must-call obligations are fulfilled.}. \todo{Should I mention here that it is an
error if that default type is not top in the CM hierarchy?}


The Must Call Consistency Checker treats calls to \<@ResetMustCall> obligations
as creating a fresh obligation to check, since they mark the beginning of a new
accumulation frame.  In terms of our pseudocode, assume we have a routine
\textsc{RMCTargets}$(s)$ that works as follows: if $s$ is a
statement invoking a \<@ResetMustCall> method $m$, \textsc{RMCTargets}$(s)$ returns
the actual parameters at $s$ corresponding to $m$'s \<@ResetMustCall> targets;
otherwise, it returns $\emptyset$.  Then, we can update the
\textsc{MCObligations} procedure of \Cref{alg:helpers} to handle
\<@ResetMustCall> as follows:
\begin{algorithmic}
  \Procedure{MCObligations}{$s$}
    \State $r \gets \textsc{RMCTargets}(s)$
    \If{$s$ is \lstinline{p = foo(...)} and \textsc{HasMCReturn}(\lstinline{foo})}
      \State $r \gets r \cup \{p\}$
    \EndIf
    \State \Return $r$
    \EndProcedure
\end{algorithmic}
Also, if during the data flow analysis, we encounter a call to a \<@ResetMustCall>
method on a tracked variable $v$, we treat the existing \<@MustCall>
obligation of $v$ as \emph{satisfied} before the call.  I.e., we add one more
case to the \textsc{MCSatisfied} predicate given in
\Cref{sec:ownership-transfer} ($[\ldots]$ stands for the previous cases):
\begin{align*}
  \exists p \in P &.\ [\ldots] \vee p \in \textsc{RMCTargets}(s)
\end{align*}
This is sound since the checker creates a new obligation for calls to
\<@ResetMustCall> methods, and the must-call obligation inference ensures the
\<@MustCall> type for the target will have a superset of any methods present
before the call.

Finally, the checker must enforce two new rules to ensure that
re-assignments to non-final, owning fields like \<sock> in the example
above are sound:
\begin{itemize}
\item any method that re-assigns a non-final, owning field of an object
  must be annotated with an \<@ResetMustCall> that targets that object.
\item when a non-final, owning field $f$ is re-assigned at statement $s$, its \<@MustCall> obligation
must be satisfied before $s$ (i.e., $\textsc{MCBefore}(f,s) \subseteq
\textsc{CMBefore}(f,s)$, see \Cref{alg:helpers})
\end{itemize}
\noindent
Together, these rules guarantee that any re-assignment to a non-final, owning
field (1) ends the current accumulation frame with the obligation fulfilled,
and (2) starts a new accumulation frame, with the obligation re-imposed on
the target at the caller.

\subsection{Unconnected sockets}
\label{sec:unconnected-sockets}
Accumulation frames can also handle cases where an object, when created,
does not actually allocate a resource---but it will allocate a resource
later in its lifecycle. Consider, for example, the no-argument constructor
to \<java.net.Socket>. This constructor does not actually allocate an
operating system-level socket, but instead just creates the container
object, which permits the programmer to e.g. set options which will be used
when creating the physical socket. When such a \<Socket> is created, it
initally has no must-call obligation; it is only when the \<Socket> is
actually connected that the must-call obligation is created.

If all \<Socket>s are treated as \<@MustCall(\{"close"\})>---that is,
without the accumulation frames described in this section---a false positive
would be reported
in code such as the below, which operates on an unconnected socket
(simplified from real code in Apache Zookeeper~\todo{cite}):

\begin{lstlisting}[frame=tb,belowskip=3mm]
  static Socket createSocket() {
    Socket sock = new Socket();
    sock.setSoTimeout(...);
    return sock;
  }
\end{lstlisting}

The call to \<setSoTimeout> can throw a \<SocketException> if the
socket is actually connected when it is called, so without an
accumulation frame our analysis would report a possible leak along
that path.  However, we can use an accumulation frame \emph{without an
  obligation}---i.e. in which the \<Socket> is \<@MustCall({})>---
that extends from the constructor call to a method that connects the
socket (such as \<connect()> or \<bind()>) to avoid this false
positive, by annotating those methods as \<@ResetMustCall("this")>.
