\section{Resource aliasing}
\label{sec:must-call-choice}

This section introduces a sound, lightweight, specialized must-alias analysis
that tracks \emph{resource alias} sets---sets of pointers that
definitely correspond to the same underlying system resource.  Closing
one alias also closes the others.  Thus,
\Tool can avoid issuing false positive warnings about resources
that have already been closed through a resource alias.  Prior
work on accumulation analyses showed that limited, specialized forms
of alias analysis can provide precision to an accumulation analysis
where needed, without incurring the cost of a whole-program
analysis~\cite{KelloggRSSE2020}; our resource alias analysis is an
example.

\subsection{Wrapper types}

Java programs extensively use \emph{wrapper types}.  For example, the Java
\<BufferedOutputStream> wrapper adds buffering to some other delegate \<OutputStream>, which
may or may not represent a resource that needs closing.  The wrapper's 
\<close()> method invokes \<close()> on the delegate.
Wrapper types
introduce two additional complexities for \MustCall checking:
\begin{enumerate}
  \item If a wrapped object has no \MustCall obligation, the corresponding
  wrapper object should also have no obligation.
  \item Satisfying the obligation of \emph{either} the wrapped object or the
  wrapper object is sufficient.
\end{enumerate}
For example, if a \<BufferedOutputStream> $b$ wraps a stream with no underlying
resource (e.g., a \<ByteArrayOutputStream>), $b$ should have an empty
\MustCall obligation, since $b$ has no resource of its own.  On the other
hand, if $b$ wraps a stream managing a resource, like a \<FileOutputStream> $f$,
then \<close()> must be invoked on \emph{either} $b$ or $f$.

Previous work has shown that reasoning about wrapper types is
required to avoid excessive false positive and duplicate
reports~\cite{TorlakC10,ecj-resource-leak}.  Wrapper types in earlier
work were handled with hard-coded specifications of which library
types are wrappers, and heuristic clustering to avoid duplicate reports for
wrappers~\cite{TorlakC10}.
% and also a clustering technique to heuristically group warnings
% involving a resource and its wrappers~\cite{TorlakC10}.
% Unlike heuristic clustering,
% our approach is sound.

Our technique handles wrapper types more generally by tracking \emph{resource
aliases} during analysis.  Two references $r_1$ and $r_2$ are resource aliases
if $r_1$ and $r_2$ are must-aliased pointers or if
satisfying $r_1$'s \MustCall obligation also satisfies $r_2$'s
  obligation, and vice-versa.

\paragraph{Introducing resource aliases}
To indicate where an API method creates a resource-alias
relationship between distinct objects, the programmer writes a pair of 
\MustCallAlias qualifiers:  one on a parameter
of a method, and another on its return type.
For example, one constructor of \<BufferedOutputStream> is:
\begin{lstlisting}[aboveskip=0.5em,belowskip=0.5em]
@MustCallAlias BufferedOutputStream(@MustCallAlias OutputStream arg0);
\end{lstlisting}
\noindent
\MustCallAlias annotations are verified, not trusted; see \cref{sec:MustCallAlias-verification}.
At a call site to a \MustCallAlias-annotated method, there are two effects.

First, the must-call type of the method call's return value
is the same as that of the \MustCallAlias
argument.  If the type of the argument has no must-call obligations (like a
\<ByteArrayOutputStream>), the returned wrapper will not have must-call
obligations, either.

Second,
the Must Call Consistency Checker
(\Cref{sec:must-call-invoked}) treats the \MustCallAlias parameter and return as
aliases.  For our \cref{sec:must-call-invoked} pseudocode, this
version of \textsc{CreatesAlias} from \cref{alg:helpers} handles resource aliases:
\begin{algorithmic}
  \Procedure{CreatesAlias}{$P,s$}
    \State \Return $\exists \mathtt{q} \in P\ .\ s$ is of the form \texttt{p = q}\newline
         \hspace*{8em} $\vee\ \textsc{IsMustCallAliasParam}(s,q)$ 
  \EndProcedure
  \Procedure{IsMustCallAliasParam}{$s,p$}
    \State \Return $s$ passes $p$ to a \MustCallAlias parameter of its callee
  \EndProcedure
\end{algorithmic}

% With this change, \cref{alg:consistency-checker} treats the
% assigned variable $p$ of a call statement as a new alias (just like a local
% variable alias) if a 
% variable in $P$ is passed to some \MustCallAlias parameter.

% As shown in
% \cref{alg:consistency-checker}, the returned set is added to the set of tracked
% variables for a resource (\cref{li:compute-new-mc-aliases}), and the algorithm
% treats satisfaction of the \MustCall obligation for any variable in the set
% as satisfying all the others.\todo{need another pass on this prose...}

\subsection{Beyond wrapper types}

\MustCallAlias can also be employed in scenarios beyond direct wrapper types, a
capability not present in previous work on resource leak detection.  In certain cases, a resource gets
shared between objects via an intermediate object that cannot directly close the
resource.  For example, \<java.io.RandomAccessFile> (which must be closed) has
a method \<getFd()> that returns a \<FileDescriptor>
object for the file. This file
descriptor cannot be closed directly---it has no \<close()> method.
However, the descriptor can be passed to a wrapper stream such as
\<FileOutputStream>, which if closed satisfies the original must-call
obligation.  By adding \MustCallAlias annotations to the \<getFd()> method, our
technique can verify code like the below (adapted from Apache Hadoop~\cite{hadoop-random-access-file}):
\begin{lstlisting}[frame=tb,belowskip=3mm]
  RandomAccessFile file = new RandomAccessFile(myFile, "rws");
  FileInputStream in = null;
  try {
    in = new FileInputStream(file.getFD());
    // do something with in  
    in.close();
  } catch (IOException e){
    file.close();
  }
\end{lstlisting}
Because the must-call obligation checker (\cref{sec:must-call})
treats \MustCallAlias annotations
polymorphically, regardless of the associated base type,
\Tool can verify that the same resource is held by
the \<Random\-Access\-File> and the \<File\-Input\-Stream>, even though it
is passed via a class without a \<close()> method.
This capability enabled
verifying multiple code patterns in our case studies.

\subsection{Verification of \MustCallAlias}\label{sec:MustCallAlias-verification}

A pair of \MustCallAlias annotations on a method or constructor \<m>'s return type
and its parameter \<p> can be verified if either of the following holds:
\begin{enumerate}
\item \<p> is passed to another method or constructor in a
  \MustCallAlias position, and \<m> returns the result of that method,
  or the call is a \<super()> constructor call appropriately annotated
  with \MustCallAlias.
\item \<p> is stored in an \<@Owning> field of the enclosing class.  (\<@Owning>
field verification is described in \cref{sec:owning-fields,sec:non-final-owning}.)
% , and the
%   class declaration has an \MustCall\<(>$A$\<)> annotation for some set
%   of methods $A$, and at least one of the methods in $A$ has an
%   \EnsuresCalledMethods postcondition annotation that names at least the
%   must-call obligations of \<p>'s static type.
\end{enumerate}
These verification procedures permit a programmer to soundly specify a resource-aliasing
relationship in their own code, a capability that was not present in prior work
that relied on a hard-coded list of wrapper types; we used this
% \todo{3 in Zookeeper + however many in the rest}
multiple times
in our case studies.

% The
% must-call obligation for an arbitrary \<BufferedOutputStream> is
% \MustCall\<(\{``close''\})>---the stream might be writing to a file,
% for example.  \<BufferedOutputStream>'s constructors all have a
% parameter which is another \<OutputStream>. When \<close()> is called
% on the resulting \<BufferedOutputStream>, the implementation calls
% \<close()> on the wrapped \<OutputStream>. Since there are no
% additional resources allocated by the \<BufferedOutputStream> that
% were not part of the \<OutputStream> passed to the constructor,
% calling \<close()> on either stream is equally correct (though most
% Java style guides suggest calling \<close()> on the outermost
% wrapper \todo{cite that claim?}).

% Code that uses these streams usually calls \<close()> on only one
% of the streams---either the wrapper stream or the wrapped stream.
% A tool that reported an error for one stream if the other was closed
% would report too many false positives to be usable in practice.
% Prior work uses a pre-determined list of wrapper classes, built into
% the tool, to handle this issue~\cite{TorlakC10}. \todo{Also cite ecj here?
%   I think it also uses the same scheme...}

% LocalWords:  BufferedOutputStream OutputStream MustCall FileOutputStream
% LocalWords:  ByteArrayOutputStream MustCallAlias arg0 CreatesAlias getFd
% LocalWords:  FileDescriptor belowskip RandomAccessFile myFile rws getFD
% LocalWords:  FileInputStream EnsuresCalledMethods
