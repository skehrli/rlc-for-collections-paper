\section{Resource aliasing}
\label{sec:must-call-choice}

This section introduces a sound, lightweight, specialized must-alias analysis
that tracks \emph{resource alias} sets---sets of pointers that
definitely correspond to the same underlying system resource.  Closing
one alias also closes the others.  Thus,
\Tool can avoid issuing false positive warnings about resources
that have already been closed through a resource alias.  Prior
work on accumulation analyses showed that limited, specialized forms
of alias analysis can provide precision to an accumulation analysis
where needed, without incurring the cost of a whole-program
analysis~\cite{KelloggRSSE2020}; our resource alias analysis is an
example.

\subsection{Wrapper types}

Java programs extensively use \emph{wrapper types}.  For example, the Java
\<BufferedOutputStream> wrapper adds buffering to some other delegate \<OutputStream>, which
may or may not represent a resource that needs closing.  The wrapper's 
\<close()> method invokes \<close()> on the delegate.
Wrapper types
introduce two additional complexities for \<@MustCall> checking:
\begin{enumerate}
  \item If a wrapped object has no \<@MustCall> obligation, the corresponding
  wrapper object should also have no obligation.
  \item Satisfying the obligation of \emph{either} the wrapped object or the
  wrapper object is sufficient.
\end{enumerate}
For example, if a \<BufferedOutputStream> $b$ wraps a stream with no underlying
resource (e.g., a \<ByteArrayOutputStream>), $b$ should have an empty
\<@MustCall> obligation, since $b$ has no resource of its own.  On the other
hand, if $b$ wraps a stream managing a resource, like a \<FileOutputStream> $f$,
then \<close()> must be invoked on \emph{either} $b$ or $f$.

Previous work has shown that reasoning about wrapper types is
required to avoid excessive false positive and duplicate
reports~\cite{TorlakC10,ecj-resource-leak}.  Wrapper types in earlier
work were handled with hard-coded specifications of which library
types are wrappers and also a clustering technique to heuristically group warnings
involving a resource and its wrappers~\cite{TorlakC10}.  \manu{is our technique better than
clustering?  i think we will only report one issue per resource, but not 100\% sure.}

Our technique handles wrapper types more generally by tracking \emph{resource
aliases} during analysis.  Two references $r_1$ and $r_2$ are resource aliases
if $r_1$ and $r_2$ are must-aliased pointers or if
satisfying $r_1$'s \<@MustCall> obligation also satisfies $r_2$'s
  obligation, and vice-versa.

\paragraph{Introducing resource aliases}
To indicate where an API method creates a resource-alias
relationship between distinct objects, the programmer writes a pair of 
\mccannot qualifiers:  one on a parameter
of a method, and another on its return type.
For example, one constructor of \<BufferedOutputStream> is:
\begin{lstlisting}
@MustCallAlias BufferedOutputStream(@MustCallAlias OutputStream arg0);
\end{lstlisting}

\noindent
\mccannot annotations are verified, not trusted; see \cref{sec:mccannot-verification}.
At a call site to a \mccannot-annotated method, there are two effects.

First, the method call's must-call type is the same as that of the
argument.  If the type of the argument has no must-call obligations (like a
\<ByteArrayOutputStream>), the returned wrapper will not have must-call
obligations, either.

Second,
the Must Call Consistency Checker
(\Cref{sec:must-call-choice}) treats the \mccannot parameter and return as
aliases.  For our \Cref{sec:must-call-invoked} pseudocode, assume\todo{Put
  this in the code snippet below instead of in text.} we have a
predicate $\textsc{IsMust\-CallAliasParam}(s,p)$ that is true iff $s$ is a call that
passes $p$ to a \mccannot parameter of the callee.
This modified
version of \textsc{CreatesAlias} from \cref{alg:helpers} handles resource aliases:
\begin{algorithmic}
  \Procedure{CreatesAlias}{$P,s$}
    \State \Return $s$ is of the form \<p = q> $\wedge\ \mathtt{q} \in P$ \newline
         \hspace*{4.5em} $\vee\ \exists p_i \in P.\ \textsc{IsMustCallAliasParam}(s,p_i)$ 
    \EndProcedure
\end{algorithmic}

% With this change, \Cref{alg:consistency-checker} treats the
% assigned variable $p$ of a call statement as a new alias (just like a local
% variable alias) if a 
% variable in $P$ is passed to some \mccannot parameter.

% As shown in
% \cref{alg:consistency-checker}, the returned set is added to the set of tracked
% variables for a resource (\cref{li:compute-new-mc-aliases}), and the algorithm
% treats satisfaction of the \<@MustCall> obligation for any variable in the set
% as satisfying all the others.\todo{need another pass on this prose...}

\subsection{Beyond wrapper types}

\mccannot can also be employed in scenarios beyond direct wrapper types, a
capability not present in previous work on resource leak detection.  In certain cases, a resource gets
shared between objects via an intermediate object that cannot directly close the
resource.  For example, \<java.io.RandomAccessFile> (which must be closed) has
a method \<getFd()> that returns a \<FileDescriptor>
object for the file. This file
descriptor cannot be closed directly---it has no \<close()> method.
However, the descriptor can be passed to a wrapper stream such as
\<FileOutputStream>, which if closed satisfies the original must-call
obligation.  By adding \mccannot annotations to the \<getFd()> method, our
technique can verify code like the below (adapted from Apache Hadoop~\cite{hadoop-random-access-file}):
\begin{lstlisting}[frame=tb,belowskip=3mm]
  RandomAccessFile file = new RandomAccessFile(myFile, "rws");
  FileInputStream in = null;
  try {
    in = new FileInputStream(file.getFD());
    // do something with in  
    in.close();
  } catch (IOException e){
    file.close();
  }
\end{lstlisting}
\Tool assigns \<FileDescriptor>\todo{This seems wrong; I think \Tool
  assigns the type to the expression \<file.getFD()>.  Please clarify.}
a special \<@MustCall(?)> type that cannot be satisfied by any calls,
but which is converted back\todo{This ``is converted back'' seems magical.
  Please explain how it happens.} into \<@MustCall("close")> when passed to the \<@MustCallAlias> constructor
of \<FileInputStream>. This capability enabled
verifying multiple code patterns in our case studies.

\subsection{Verification of \mccannot}\label{sec:mccannot-verification}

A pair of \mccannot annotations on a method or constructor \<m>'s return type
and its parameter \<p> can be verified if either of the following holds:
\begin{enumerate}
\item \<p> is passed to another method or constructor in a
  \mccannot position, and \<m> returns the result of that method
  or the call is a \<super()> constructor call appropriately annotated
  with \mccannot.
\item \<p> is stored in an \<@Owning> field of the class, and the
  class declaration has an \<@MustCall(>$A$\<)> annotation for some set
  of methods $A$, and at least one of the methods in $A$ has an
  \<@EnsuresCalledMethods> postcondition annotation that names at least the
  must-call obligations of \<p>'s static type.
\end{enumerate}
These verification procedures permit a programmer to soundly specify a resource-aliasing
relationship in their own code, a capability that was not present in prior work
that relies on a hard-coded list of wrapper types.  we used this
% \todo{3 in Zookeeper + however many in the rest}
multiple times
in our case studies

% As noted in previous work, p
% The
% must-call obligation for an arbitrary \<BufferedOutputStream> is
% \<@MustCall(\{``close''\})>---the stream might be writing to a file,
% for example.  \<BufferedOutputStream>'s constructors all have a
% parameter which is another \<OutputStream>. When \<close()> is called
% on the resulting \<BufferedOutputStream>, the implementation calls
% \<close()> on the wrapped \<OutputStream>. Since there are no
% additional resources allocated by the \<BufferedOutputStream> that
% were not part of the \<OutputStream> passed to the constructor,
% calling \<close()> on either stream is equally correct (though most
% Java style guides suggest calling \<close()> on the outermost
% wrapper \todo{cite that claim?}).

% Code that uses these streams usually calls \<close()> on only one
% of the streams---either the wrapper stream or the wrapped stream.
% A tool that reported an error for one stream if the other was closed
% would report too many false positives to be usable in practice.
% Prior work uses a pre-determined list of wrapper classes, built into
% the tool, to handle this issue~\cite{TorlakC10}. \todo{Also cite ecj here?
%   I think it also uses the same scheme...}

% LocalWords:  BufferedOutputStream OutputStream MustCall FileOutputStream
% LocalWords:  ByteArrayOutputStream MustCallAlias arg0 CreatesAlias getFd
% LocalWords:  FileDescriptor belowskip RandomAccessFile myFile rws getFD
% LocalWords:  FileInputStream EnsuresCalledMethods
