\section{Resource aliasing}
\label{sec:must-call-choice}

This section introduces a lightweight, specialized must-alias analysis
that tracks \emph{resource alias} sets---sets of pointers that
definitely correspond to the same underlying system resource.  Because
resource aliases correspond to the same underlying resource, closing
one alias also closes the other---so our sound resource alias analysis
permits \Tool to avoid issuing false positive warnings about resources
that have already been closed through their resource aliases.  Prior
work on accumulation analyses showed that limited, specialized forms
of alias analysis can provide precision to an accumulation analysis
where needed, without incurring the cost of a whole-program
analysis~\cite{KelloggRSSE2020}; our resource alias analysis is no
different.

\subsection{Wrapper types}

Precise leak detection for Java requires reasoning about \emph{wrapper types},
which wrap another type that may contain a resource.  For example, the Java
\<BufferedOutputStream> type adds buffering to some other \<OutputStream>, which
may or may not represent a resource that needs closing.  Wrapper types
introduce two additional complexities for \<@MustCall> checking:
\begin{enumerate}
  \item If a wrapped object has no \<@MustCall> obligation, the corresponding
  wrapper object should also have no obligation.
  \item Satisfying the obligation of \emph{either} the wrapped object or the
  wrapper object is sufficient.
\end{enumerate}
For example, if a \<BufferedOutputStream> $b$ wraps a stream with no underlying
resource (e.g., a \<ByteArrayOutputStream>), $b$ should have an empty
\<@MustCall> obligation, since $b$ has no resource of its own.  On the other
hand, if $b$ wraps a stream managing a resource, like a \<FileOutputStream> $f$,
then \<close()> must be invoked on \emph{either} $b$ or $f$. Calling \<close()> on $b$
is sufficient since $b$\<.close()> invokes \<close()> on its wrapped stream $f$.

Previous work has shown that a reasoning about wrapper types is
required to avoid excessive false positive and duplicate
reports~\cite{TorlakC10,ecj-resource-leak}.  Wrapper types in earlier
work were handled with hard-coded specifications of which library
types are wrappers and also, in the work of Torlak and
Chandra~\cite{TorlakC10}, a clustering technique to group warnings
involving a resource and its wrappers.

Our technique handles wrapper types more generally by tracking \emph{resource
aliases} during analysis.  Two references $r_1$ and $r_2$ are resource aliases
iff:
\begin{itemize}
\item satisfying $r_1$'s \<@MustCall> obligation also satisfies $r_2$'s
  obligation, and vice-versa; or
\item if $r_1$ and $r_2$ are must-aliased pointers.
\end{itemize}
We also introduce a new type
qualifier \mccannot to indicate where an API method creates a resource-alias
relationship between distinct objects, like a wrapper and the wrapped resource.
\mccannot can be used to annotate a \<BufferedOutputStream> constructor as follows:
\begin{lstlisting}
@MustCallAlias BufferedOutputStream(@MustCallAlias OutputStream arg0);
\end{lstlisting}

\mccannot qualifiers must always appear in pairs---one on a parameter
of a method, and another on its return type.  A pair of \mccannot
annotations has two effects on our inference and checking.  First,
must-call obligation inference (\Cref{sec:must-call}) treats the
annotated elements as polymorphic---the must-call obligations of the
parameter are copied to the return type. Therefore, if the wrapped
type has no must-call obligations (like a \<ByteArrayOutputStream>),
the wrapper will not have must-call obligations, either.

Second, at call sites, the Must Call Consistency Checker
(\Cref{sec:must-call-choice}) treats the \mccannot parameter and return as
aliases.  Specifically, the \textsc{CreatesAlias} routine in \cref{alg:helpers} is
modified as follows \todo{better notation!}:
\begin{algorithmic}
  \Procedure{CreatesAlias}{$P,s$}
    \State \Return $s$ is \lstinline{p = q} $\wedge\ q \in P$ \newline
         \hspace*{4.5em} $\vee$ $(s$ is \lstinline{p = foo(p1, p2, ...)} \newline
         \hspace*{6em} $\wedge\ \exists p_i \in P.\ q_i$ is
         \lstinline{@MustCallAlias} in \lstinline{foo})
    \EndProcedure
\end{algorithmic}
Beyond must-aliasing between local variables, the routine now treats the
assigned variable $p$ of a call statement as a new resource alias if a tracked
variable in $P$ is passed to some \mccannot parameter.
With this change, \Cref{alg:consistency-checker} will treat the case of a
resource alias exactly the same as a standard must alias.
% As shown in
% \cref{alg:consistency-checker}, the returned set is added to the set of tracked
% variables for a resource (\cref{li:compute-new-mc-aliases}), and the algorithm
% treats satisfaction of the \<@MustCall> obligation for any variable in the set
% as satisfying all the others.\todo{need another pass on this prose...}

\subsection{Beyond wrapper types}

\mccannot can also be employed in scenarios beyond direct wrapper types, a
capability not present in previous work.  In certain cases, a resource gets
shared between objects via an intermediate object that cannot directly close the
resource.  For example, \<java.io.RandomAccessFile> (which must be closed) has
a method \<getFd()> that returns a \<FileDescriptor>
object for the file. This file
descriptor cannot be closed directly---it has no \<close()> method.
However, the descriptor can be passed to a wrapper stream such as
\<FileOutputStream>, which if closed satisfies the original must-call
obligation.  By adding \mccannot annotations to the \<getFd()> method, our
technique can verify code like the below (from \todo{which case study?}):
\begin{lstlisting}[frame=tb,belowskip=3mm]
  RandomAccessFile file = new RandomAccessFile(myFile, "rws");
  FileInputStream in = null;
  try {
    in = new FileInputStream(file.getFD());
    // do something with in  
    in.close();
  } catch (IOException e){
    file.close();
  }
\end{lstlisting}
We assign \<FileDescriptor> a special \<@MustCall(?)> type that cannot be satisfied by any calls,
but which is converted back into \<@MustCall("close")> when passed to the \<@MustCallAlias> constructor
of \<FileInputStream>. We found this capability to be
useful for verifying multiple code patterns in our case studies.

\subsection{Verification of \mccannot}

A pair of \mccannot annotations on a method or constructor \<m>'s return type
and its parameter \<p> can be verified via one of two
procedures:
\begin{enumerate}
\item if \<p> is passed to another method or constructor in an
  \mccannot position, and \<m> returns the result of that method
  (or the method is a \<super()> constructor call appropriately annotated
  with \mccannot), then the code can be verified.
\item if \<p> is stored in an \<@Owning> field of the class, and the
  class declaration has an \<@MustCall(>$A$\<)> annotation for some set
  of methods $A$, and at least one of the methods in $A$ has an
  \<@EnsuresCalledMethods> annotation naming at least the
  must-call obligations of \<p>'s static type, then the code can be verified.
\end{enumerate}
These verification procedures permit a programmer to soundly specify a resource-aliasing
relationship in their own code, a capability that was not present in prior work
that relies on a hard-coded list of wrapper types, and that we used in our case studies
\todo{3 in Zookeeper + however many in the rest} times.

% As noted in previous work, p
% The
% must-call obligation for an arbitrary \<BufferedOutputStream> is
% \<@MustCall(\{``close''\})>---the stream might be writing to a file,
% for example.  \<BufferedOutputStream>'s constructors all have a
% parameter which is another \<OutputStream>. When \<close()> is called
% on the resulting \<BufferedOutputStream>, the implementation calls
% \<close()> on the wrapped \<OutputStream>. Since there are no
% additional resources allocated by the \<BufferedOutputStream> that
% were not part of the \<OutputStream> passed to the constructor,
% calling \<close()> on either stream is equally correct (though most
% Java style guides suggest calling \<close()> on the outermost
% wrapper \todo{cite that claim?}).

% Code that uses these streams usually calls \<close()> on only one
% of the streams---either the wrapper stream or the wrapped stream.
% A tool that reported an error for one stream if the other was closed
% would report too many false positives to be usable in practice.
% Prior work uses a pre-determined list of wrapper classes, built into
% the tool, to handle this issue~\cite{TorlakC10}. \todo{Also cite ecj here?
%   I think it also uses the same scheme...}

% LocalWords:  BufferedOutputStream OutputStream MustCall FileOutputStream
% LocalWords:  ByteArrayOutputStream MustCallAlias arg0 CreatesAlias getFd
% LocalWords:  FileDescriptor belowskip RandomAccessFile myFile rws getFD
% LocalWords:  FileInputStream EnsuresCalledMethods
